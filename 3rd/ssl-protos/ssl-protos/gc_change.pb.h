// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gc_change.proto

#ifndef PROTOBUF_INCLUDED_gc_5fchange_2eproto
#define PROTOBUF_INCLUDED_gc_5fchange_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "gc_state.pb.h"
#include "gc_common.pb.h"
#include "gc_geometry.pb.h"
#include "gc_game_event.pb.h"
#include "gc_referee_message.pb.h"
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_gc_5fchange_2eproto 

namespace protobuf_gc_5fchange_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[19];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_gc_5fchange_2eproto
namespace ssl_protos {
namespace gc {
class AcceptProposalGroup;
class AcceptProposalGroupDefaultTypeInternal;
extern AcceptProposalGroupDefaultTypeInternal _AcceptProposalGroup_default_instance_;
class AddGameEvent;
class AddGameEventDefaultTypeInternal;
extern AddGameEventDefaultTypeInternal _AddGameEvent_default_instance_;
class AddPassiveGameEvent;
class AddPassiveGameEventDefaultTypeInternal;
extern AddPassiveGameEventDefaultTypeInternal _AddPassiveGameEvent_default_instance_;
class AddProposal;
class AddProposalDefaultTypeInternal;
extern AddProposalDefaultTypeInternal _AddProposal_default_instance_;
class AddRedCard;
class AddRedCardDefaultTypeInternal;
extern AddRedCardDefaultTypeInternal _AddRedCard_default_instance_;
class AddYellowCard;
class AddYellowCardDefaultTypeInternal;
extern AddYellowCardDefaultTypeInternal _AddYellowCard_default_instance_;
class Change;
class ChangeDefaultTypeInternal;
extern ChangeDefaultTypeInternal _Change_default_instance_;
class ChangeStage;
class ChangeStageDefaultTypeInternal;
extern ChangeStageDefaultTypeInternal _ChangeStage_default_instance_;
class Continue;
class ContinueDefaultTypeInternal;
extern ContinueDefaultTypeInternal _Continue_default_instance_;
class NewCommand;
class NewCommandDefaultTypeInternal;
extern NewCommandDefaultTypeInternal _NewCommand_default_instance_;
class NewGameState;
class NewGameStateDefaultTypeInternal;
extern NewGameStateDefaultTypeInternal _NewGameState_default_instance_;
class Revert;
class RevertDefaultTypeInternal;
extern RevertDefaultTypeInternal _Revert_default_instance_;
class SetBallPlacementPos;
class SetBallPlacementPosDefaultTypeInternal;
extern SetBallPlacementPosDefaultTypeInternal _SetBallPlacementPos_default_instance_;
class StartBallPlacement;
class StartBallPlacementDefaultTypeInternal;
extern StartBallPlacementDefaultTypeInternal _StartBallPlacement_default_instance_;
class StateChange;
class StateChangeDefaultTypeInternal;
extern StateChangeDefaultTypeInternal _StateChange_default_instance_;
class SwitchColors;
class SwitchColorsDefaultTypeInternal;
extern SwitchColorsDefaultTypeInternal _SwitchColors_default_instance_;
class UpdateConfig;
class UpdateConfigDefaultTypeInternal;
extern UpdateConfigDefaultTypeInternal _UpdateConfig_default_instance_;
class UpdateTeamState;
class UpdateTeamStateDefaultTypeInternal;
extern UpdateTeamStateDefaultTypeInternal _UpdateTeamState_default_instance_;
class YellowCardOver;
class YellowCardOverDefaultTypeInternal;
extern YellowCardOverDefaultTypeInternal _YellowCardOver_default_instance_;
}  // namespace gc
}  // namespace ssl_protos
namespace google {
namespace protobuf {
template<> ::ssl_protos::gc::AcceptProposalGroup* Arena::CreateMaybeMessage<::ssl_protos::gc::AcceptProposalGroup>(Arena*);
template<> ::ssl_protos::gc::AddGameEvent* Arena::CreateMaybeMessage<::ssl_protos::gc::AddGameEvent>(Arena*);
template<> ::ssl_protos::gc::AddPassiveGameEvent* Arena::CreateMaybeMessage<::ssl_protos::gc::AddPassiveGameEvent>(Arena*);
template<> ::ssl_protos::gc::AddProposal* Arena::CreateMaybeMessage<::ssl_protos::gc::AddProposal>(Arena*);
template<> ::ssl_protos::gc::AddRedCard* Arena::CreateMaybeMessage<::ssl_protos::gc::AddRedCard>(Arena*);
template<> ::ssl_protos::gc::AddYellowCard* Arena::CreateMaybeMessage<::ssl_protos::gc::AddYellowCard>(Arena*);
template<> ::ssl_protos::gc::Change* Arena::CreateMaybeMessage<::ssl_protos::gc::Change>(Arena*);
template<> ::ssl_protos::gc::ChangeStage* Arena::CreateMaybeMessage<::ssl_protos::gc::ChangeStage>(Arena*);
template<> ::ssl_protos::gc::Continue* Arena::CreateMaybeMessage<::ssl_protos::gc::Continue>(Arena*);
template<> ::ssl_protos::gc::NewCommand* Arena::CreateMaybeMessage<::ssl_protos::gc::NewCommand>(Arena*);
template<> ::ssl_protos::gc::NewGameState* Arena::CreateMaybeMessage<::ssl_protos::gc::NewGameState>(Arena*);
template<> ::ssl_protos::gc::Revert* Arena::CreateMaybeMessage<::ssl_protos::gc::Revert>(Arena*);
template<> ::ssl_protos::gc::SetBallPlacementPos* Arena::CreateMaybeMessage<::ssl_protos::gc::SetBallPlacementPos>(Arena*);
template<> ::ssl_protos::gc::StartBallPlacement* Arena::CreateMaybeMessage<::ssl_protos::gc::StartBallPlacement>(Arena*);
template<> ::ssl_protos::gc::StateChange* Arena::CreateMaybeMessage<::ssl_protos::gc::StateChange>(Arena*);
template<> ::ssl_protos::gc::SwitchColors* Arena::CreateMaybeMessage<::ssl_protos::gc::SwitchColors>(Arena*);
template<> ::ssl_protos::gc::UpdateConfig* Arena::CreateMaybeMessage<::ssl_protos::gc::UpdateConfig>(Arena*);
template<> ::ssl_protos::gc::UpdateTeamState* Arena::CreateMaybeMessage<::ssl_protos::gc::UpdateTeamState>(Arena*);
template<> ::ssl_protos::gc::YellowCardOver* Arena::CreateMaybeMessage<::ssl_protos::gc::YellowCardOver>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace ssl_protos {
namespace gc {

// ===================================================================

class StateChange : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ssl_protos.gc.StateChange) */ {
 public:
  StateChange();
  virtual ~StateChange();

  StateChange(const StateChange& from);

  inline StateChange& operator=(const StateChange& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StateChange(StateChange&& from) noexcept
    : StateChange() {
    *this = ::std::move(from);
  }

  inline StateChange& operator=(StateChange&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StateChange& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StateChange* internal_default_instance() {
    return reinterpret_cast<const StateChange*>(
               &_StateChange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(StateChange* other);
  friend void swap(StateChange& a, StateChange& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StateChange* New() const final {
    return CreateMaybeMessage<StateChange>(NULL);
  }

  StateChange* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StateChange>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StateChange& from);
  void MergeFrom(const StateChange& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StateChange* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ssl_protos.gc.State state_pre = 2;
  bool has_state_pre() const;
  void clear_state_pre();
  static const int kStatePreFieldNumber = 2;
  private:
  const ::ssl_protos::gc::State& _internal_state_pre() const;
  public:
  const ::ssl_protos::gc::State& state_pre() const;
  ::ssl_protos::gc::State* release_state_pre();
  ::ssl_protos::gc::State* mutable_state_pre();
  void set_allocated_state_pre(::ssl_protos::gc::State* state_pre);

  // optional .ssl_protos.gc.State state = 3;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 3;
  private:
  const ::ssl_protos::gc::State& _internal_state() const;
  public:
  const ::ssl_protos::gc::State& state() const;
  ::ssl_protos::gc::State* release_state();
  ::ssl_protos::gc::State* mutable_state();
  void set_allocated_state(::ssl_protos::gc::State* state);

  // optional .ssl_protos.gc.Change change = 4;
  bool has_change() const;
  void clear_change();
  static const int kChangeFieldNumber = 4;
  private:
  const ::ssl_protos::gc::Change& _internal_change() const;
  public:
  const ::ssl_protos::gc::Change& change() const;
  ::ssl_protos::gc::Change* release_change();
  ::ssl_protos::gc::Change* mutable_change();
  void set_allocated_change(::ssl_protos::gc::Change* change);

  // optional .google.protobuf.Timestamp timestamp = 5;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 5;
  private:
  const ::google::protobuf::Timestamp& _internal_timestamp() const;
  public:
  const ::google::protobuf::Timestamp& timestamp() const;
  ::google::protobuf::Timestamp* release_timestamp();
  ::google::protobuf::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::google::protobuf::Timestamp* timestamp);

  // optional int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ssl_protos.gc.StateChange)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_state_pre();
  void clear_has_state_pre();
  void set_has_state();
  void clear_has_state();
  void set_has_change();
  void clear_has_change();
  void set_has_timestamp();
  void clear_has_timestamp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ssl_protos::gc::State* state_pre_;
  ::ssl_protos::gc::State* state_;
  ::ssl_protos::gc::Change* change_;
  ::google::protobuf::Timestamp* timestamp_;
  ::google::protobuf::int32 id_;
  friend struct ::protobuf_gc_5fchange_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Change : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ssl_protos.gc.Change) */ {
 public:
  Change();
  virtual ~Change();

  Change(const Change& from);

  inline Change& operator=(const Change& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Change(Change&& from) noexcept
    : Change() {
    *this = ::std::move(from);
  }

  inline Change& operator=(Change&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Change& default_instance();

  enum ChangeCase {
    kNewCommand = 2,
    kChangeStage = 3,
    kSetBallPlacementPos = 4,
    kAddYellowCard = 5,
    kAddRedCard = 6,
    kYellowCardOver = 7,
    kAddGameEvent = 8,
    kAddPassiveGameEvent = 19,
    kAddProposal = 9,
    kStartBallPlacement = 10,
    kContinue = 11,
    kUpdateConfig = 12,
    kUpdateTeamState = 13,
    kSwitchColors = 14,
    kRevert = 15,
    kNewGameState = 17,
    kAcceptProposalGroup = 18,
    CHANGE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Change* internal_default_instance() {
    return reinterpret_cast<const Change*>(
               &_Change_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Change* other);
  friend void swap(Change& a, Change& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Change* New() const final {
    return CreateMaybeMessage<Change>(NULL);
  }

  Change* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Change>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Change& from);
  void MergeFrom(const Change& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Change* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string origin = 1;
  bool has_origin() const;
  void clear_origin();
  static const int kOriginFieldNumber = 1;
  const ::std::string& origin() const;
  void set_origin(const ::std::string& value);
  #if LANG_CXX11
  void set_origin(::std::string&& value);
  #endif
  void set_origin(const char* value);
  void set_origin(const char* value, size_t size);
  ::std::string* mutable_origin();
  ::std::string* release_origin();
  void set_allocated_origin(::std::string* origin);

  // optional bool revertible = 16;
  bool has_revertible() const;
  void clear_revertible();
  static const int kRevertibleFieldNumber = 16;
  bool revertible() const;
  void set_revertible(bool value);

  // optional .ssl_protos.gc.NewCommand new_command = 2;
  bool has_new_command() const;
  void clear_new_command();
  static const int kNewCommandFieldNumber = 2;
  private:
  const ::ssl_protos::gc::NewCommand& _internal_new_command() const;
  public:
  const ::ssl_protos::gc::NewCommand& new_command() const;
  ::ssl_protos::gc::NewCommand* release_new_command();
  ::ssl_protos::gc::NewCommand* mutable_new_command();
  void set_allocated_new_command(::ssl_protos::gc::NewCommand* new_command);

  // optional .ssl_protos.gc.ChangeStage change_stage = 3;
  bool has_change_stage() const;
  void clear_change_stage();
  static const int kChangeStageFieldNumber = 3;
  private:
  const ::ssl_protos::gc::ChangeStage& _internal_change_stage() const;
  public:
  const ::ssl_protos::gc::ChangeStage& change_stage() const;
  ::ssl_protos::gc::ChangeStage* release_change_stage();
  ::ssl_protos::gc::ChangeStage* mutable_change_stage();
  void set_allocated_change_stage(::ssl_protos::gc::ChangeStage* change_stage);

  // optional .ssl_protos.gc.SetBallPlacementPos set_ball_placement_pos = 4;
  bool has_set_ball_placement_pos() const;
  void clear_set_ball_placement_pos();
  static const int kSetBallPlacementPosFieldNumber = 4;
  private:
  const ::ssl_protos::gc::SetBallPlacementPos& _internal_set_ball_placement_pos() const;
  public:
  const ::ssl_protos::gc::SetBallPlacementPos& set_ball_placement_pos() const;
  ::ssl_protos::gc::SetBallPlacementPos* release_set_ball_placement_pos();
  ::ssl_protos::gc::SetBallPlacementPos* mutable_set_ball_placement_pos();
  void set_allocated_set_ball_placement_pos(::ssl_protos::gc::SetBallPlacementPos* set_ball_placement_pos);

  // optional .ssl_protos.gc.AddYellowCard add_yellow_card = 5;
  bool has_add_yellow_card() const;
  void clear_add_yellow_card();
  static const int kAddYellowCardFieldNumber = 5;
  private:
  const ::ssl_protos::gc::AddYellowCard& _internal_add_yellow_card() const;
  public:
  const ::ssl_protos::gc::AddYellowCard& add_yellow_card() const;
  ::ssl_protos::gc::AddYellowCard* release_add_yellow_card();
  ::ssl_protos::gc::AddYellowCard* mutable_add_yellow_card();
  void set_allocated_add_yellow_card(::ssl_protos::gc::AddYellowCard* add_yellow_card);

  // optional .ssl_protos.gc.AddRedCard add_red_card = 6;
  bool has_add_red_card() const;
  void clear_add_red_card();
  static const int kAddRedCardFieldNumber = 6;
  private:
  const ::ssl_protos::gc::AddRedCard& _internal_add_red_card() const;
  public:
  const ::ssl_protos::gc::AddRedCard& add_red_card() const;
  ::ssl_protos::gc::AddRedCard* release_add_red_card();
  ::ssl_protos::gc::AddRedCard* mutable_add_red_card();
  void set_allocated_add_red_card(::ssl_protos::gc::AddRedCard* add_red_card);

  // optional .ssl_protos.gc.YellowCardOver yellow_card_over = 7;
  bool has_yellow_card_over() const;
  void clear_yellow_card_over();
  static const int kYellowCardOverFieldNumber = 7;
  private:
  const ::ssl_protos::gc::YellowCardOver& _internal_yellow_card_over() const;
  public:
  const ::ssl_protos::gc::YellowCardOver& yellow_card_over() const;
  ::ssl_protos::gc::YellowCardOver* release_yellow_card_over();
  ::ssl_protos::gc::YellowCardOver* mutable_yellow_card_over();
  void set_allocated_yellow_card_over(::ssl_protos::gc::YellowCardOver* yellow_card_over);

  // optional .ssl_protos.gc.AddGameEvent add_game_event = 8;
  bool has_add_game_event() const;
  void clear_add_game_event();
  static const int kAddGameEventFieldNumber = 8;
  private:
  const ::ssl_protos::gc::AddGameEvent& _internal_add_game_event() const;
  public:
  const ::ssl_protos::gc::AddGameEvent& add_game_event() const;
  ::ssl_protos::gc::AddGameEvent* release_add_game_event();
  ::ssl_protos::gc::AddGameEvent* mutable_add_game_event();
  void set_allocated_add_game_event(::ssl_protos::gc::AddGameEvent* add_game_event);

  // optional .ssl_protos.gc.AddPassiveGameEvent add_passive_game_event = 19;
  bool has_add_passive_game_event() const;
  void clear_add_passive_game_event();
  static const int kAddPassiveGameEventFieldNumber = 19;
  private:
  const ::ssl_protos::gc::AddPassiveGameEvent& _internal_add_passive_game_event() const;
  public:
  const ::ssl_protos::gc::AddPassiveGameEvent& add_passive_game_event() const;
  ::ssl_protos::gc::AddPassiveGameEvent* release_add_passive_game_event();
  ::ssl_protos::gc::AddPassiveGameEvent* mutable_add_passive_game_event();
  void set_allocated_add_passive_game_event(::ssl_protos::gc::AddPassiveGameEvent* add_passive_game_event);

  // optional .ssl_protos.gc.AddProposal add_proposal = 9;
  bool has_add_proposal() const;
  void clear_add_proposal();
  static const int kAddProposalFieldNumber = 9;
  private:
  const ::ssl_protos::gc::AddProposal& _internal_add_proposal() const;
  public:
  const ::ssl_protos::gc::AddProposal& add_proposal() const;
  ::ssl_protos::gc::AddProposal* release_add_proposal();
  ::ssl_protos::gc::AddProposal* mutable_add_proposal();
  void set_allocated_add_proposal(::ssl_protos::gc::AddProposal* add_proposal);

  // optional .ssl_protos.gc.StartBallPlacement start_ball_placement = 10;
  bool has_start_ball_placement() const;
  void clear_start_ball_placement();
  static const int kStartBallPlacementFieldNumber = 10;
  private:
  const ::ssl_protos::gc::StartBallPlacement& _internal_start_ball_placement() const;
  public:
  const ::ssl_protos::gc::StartBallPlacement& start_ball_placement() const;
  ::ssl_protos::gc::StartBallPlacement* release_start_ball_placement();
  ::ssl_protos::gc::StartBallPlacement* mutable_start_ball_placement();
  void set_allocated_start_ball_placement(::ssl_protos::gc::StartBallPlacement* start_ball_placement);

  // optional .ssl_protos.gc.Continue continue = 11;
  bool has_continue_() const;
  void clear_continue_();
  static const int kContinueFieldNumber = 11;
  private:
  const ::ssl_protos::gc::Continue& _internal_continue_() const;
  public:
  const ::ssl_protos::gc::Continue& continue_() const;
  ::ssl_protos::gc::Continue* release_continue_();
  ::ssl_protos::gc::Continue* mutable_continue_();
  void set_allocated_continue_(::ssl_protos::gc::Continue* continue_);

  // optional .ssl_protos.gc.UpdateConfig update_config = 12;
  bool has_update_config() const;
  void clear_update_config();
  static const int kUpdateConfigFieldNumber = 12;
  private:
  const ::ssl_protos::gc::UpdateConfig& _internal_update_config() const;
  public:
  const ::ssl_protos::gc::UpdateConfig& update_config() const;
  ::ssl_protos::gc::UpdateConfig* release_update_config();
  ::ssl_protos::gc::UpdateConfig* mutable_update_config();
  void set_allocated_update_config(::ssl_protos::gc::UpdateConfig* update_config);

  // optional .ssl_protos.gc.UpdateTeamState update_team_state = 13;
  bool has_update_team_state() const;
  void clear_update_team_state();
  static const int kUpdateTeamStateFieldNumber = 13;
  private:
  const ::ssl_protos::gc::UpdateTeamState& _internal_update_team_state() const;
  public:
  const ::ssl_protos::gc::UpdateTeamState& update_team_state() const;
  ::ssl_protos::gc::UpdateTeamState* release_update_team_state();
  ::ssl_protos::gc::UpdateTeamState* mutable_update_team_state();
  void set_allocated_update_team_state(::ssl_protos::gc::UpdateTeamState* update_team_state);

  // optional .ssl_protos.gc.SwitchColors switch_colors = 14;
  bool has_switch_colors() const;
  void clear_switch_colors();
  static const int kSwitchColorsFieldNumber = 14;
  private:
  const ::ssl_protos::gc::SwitchColors& _internal_switch_colors() const;
  public:
  const ::ssl_protos::gc::SwitchColors& switch_colors() const;
  ::ssl_protos::gc::SwitchColors* release_switch_colors();
  ::ssl_protos::gc::SwitchColors* mutable_switch_colors();
  void set_allocated_switch_colors(::ssl_protos::gc::SwitchColors* switch_colors);

  // optional .ssl_protos.gc.Revert revert = 15;
  bool has_revert() const;
  void clear_revert();
  static const int kRevertFieldNumber = 15;
  private:
  const ::ssl_protos::gc::Revert& _internal_revert() const;
  public:
  const ::ssl_protos::gc::Revert& revert() const;
  ::ssl_protos::gc::Revert* release_revert();
  ::ssl_protos::gc::Revert* mutable_revert();
  void set_allocated_revert(::ssl_protos::gc::Revert* revert);

  // optional .ssl_protos.gc.NewGameState new_game_state = 17;
  bool has_new_game_state() const;
  void clear_new_game_state();
  static const int kNewGameStateFieldNumber = 17;
  private:
  const ::ssl_protos::gc::NewGameState& _internal_new_game_state() const;
  public:
  const ::ssl_protos::gc::NewGameState& new_game_state() const;
  ::ssl_protos::gc::NewGameState* release_new_game_state();
  ::ssl_protos::gc::NewGameState* mutable_new_game_state();
  void set_allocated_new_game_state(::ssl_protos::gc::NewGameState* new_game_state);

  // optional .ssl_protos.gc.AcceptProposalGroup accept_proposal_group = 18;
  bool has_accept_proposal_group() const;
  void clear_accept_proposal_group();
  static const int kAcceptProposalGroupFieldNumber = 18;
  private:
  const ::ssl_protos::gc::AcceptProposalGroup& _internal_accept_proposal_group() const;
  public:
  const ::ssl_protos::gc::AcceptProposalGroup& accept_proposal_group() const;
  ::ssl_protos::gc::AcceptProposalGroup* release_accept_proposal_group();
  ::ssl_protos::gc::AcceptProposalGroup* mutable_accept_proposal_group();
  void set_allocated_accept_proposal_group(::ssl_protos::gc::AcceptProposalGroup* accept_proposal_group);

  void clear_change();
  ChangeCase change_case() const;
  // @@protoc_insertion_point(class_scope:ssl_protos.gc.Change)
 private:
  void set_has_origin();
  void clear_has_origin();
  void set_has_revertible();
  void clear_has_revertible();
  void set_has_new_command();
  void set_has_change_stage();
  void set_has_set_ball_placement_pos();
  void set_has_add_yellow_card();
  void set_has_add_red_card();
  void set_has_yellow_card_over();
  void set_has_add_game_event();
  void set_has_add_passive_game_event();
  void set_has_add_proposal();
  void set_has_start_ball_placement();
  void set_has_continue_();
  void set_has_update_config();
  void set_has_update_team_state();
  void set_has_switch_colors();
  void set_has_revert();
  void set_has_new_game_state();
  void set_has_accept_proposal_group();

  inline bool has_change() const;
  inline void clear_has_change();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr origin_;
  bool revertible_;
  union ChangeUnion {
    ChangeUnion() {}
    ::ssl_protos::gc::NewCommand* new_command_;
    ::ssl_protos::gc::ChangeStage* change_stage_;
    ::ssl_protos::gc::SetBallPlacementPos* set_ball_placement_pos_;
    ::ssl_protos::gc::AddYellowCard* add_yellow_card_;
    ::ssl_protos::gc::AddRedCard* add_red_card_;
    ::ssl_protos::gc::YellowCardOver* yellow_card_over_;
    ::ssl_protos::gc::AddGameEvent* add_game_event_;
    ::ssl_protos::gc::AddPassiveGameEvent* add_passive_game_event_;
    ::ssl_protos::gc::AddProposal* add_proposal_;
    ::ssl_protos::gc::StartBallPlacement* start_ball_placement_;
    ::ssl_protos::gc::Continue* continue__;
    ::ssl_protos::gc::UpdateConfig* update_config_;
    ::ssl_protos::gc::UpdateTeamState* update_team_state_;
    ::ssl_protos::gc::SwitchColors* switch_colors_;
    ::ssl_protos::gc::Revert* revert_;
    ::ssl_protos::gc::NewGameState* new_game_state_;
    ::ssl_protos::gc::AcceptProposalGroup* accept_proposal_group_;
  } change_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_gc_5fchange_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NewCommand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ssl_protos.gc.NewCommand) */ {
 public:
  NewCommand();
  virtual ~NewCommand();

  NewCommand(const NewCommand& from);

  inline NewCommand& operator=(const NewCommand& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NewCommand(NewCommand&& from) noexcept
    : NewCommand() {
    *this = ::std::move(from);
  }

  inline NewCommand& operator=(NewCommand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NewCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NewCommand* internal_default_instance() {
    return reinterpret_cast<const NewCommand*>(
               &_NewCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(NewCommand* other);
  friend void swap(NewCommand& a, NewCommand& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NewCommand* New() const final {
    return CreateMaybeMessage<NewCommand>(NULL);
  }

  NewCommand* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NewCommand>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NewCommand& from);
  void MergeFrom(const NewCommand& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewCommand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ssl_protos.gc.Command command = 1;
  bool has_command() const;
  void clear_command();
  static const int kCommandFieldNumber = 1;
  private:
  const ::ssl_protos::gc::Command& _internal_command() const;
  public:
  const ::ssl_protos::gc::Command& command() const;
  ::ssl_protos::gc::Command* release_command();
  ::ssl_protos::gc::Command* mutable_command();
  void set_allocated_command(::ssl_protos::gc::Command* command);

  // @@protoc_insertion_point(class_scope:ssl_protos.gc.NewCommand)
 private:
  void set_has_command();
  void clear_has_command();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ssl_protos::gc::Command* command_;
  friend struct ::protobuf_gc_5fchange_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ChangeStage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ssl_protos.gc.ChangeStage) */ {
 public:
  ChangeStage();
  virtual ~ChangeStage();

  ChangeStage(const ChangeStage& from);

  inline ChangeStage& operator=(const ChangeStage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChangeStage(ChangeStage&& from) noexcept
    : ChangeStage() {
    *this = ::std::move(from);
  }

  inline ChangeStage& operator=(ChangeStage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangeStage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChangeStage* internal_default_instance() {
    return reinterpret_cast<const ChangeStage*>(
               &_ChangeStage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ChangeStage* other);
  friend void swap(ChangeStage& a, ChangeStage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChangeStage* New() const final {
    return CreateMaybeMessage<ChangeStage>(NULL);
  }

  ChangeStage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ChangeStage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ChangeStage& from);
  void MergeFrom(const ChangeStage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeStage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ssl_protos.gc.Referee.Stage new_stage = 1;
  bool has_new_stage() const;
  void clear_new_stage();
  static const int kNewStageFieldNumber = 1;
  ::ssl_protos::gc::Referee_Stage new_stage() const;
  void set_new_stage(::ssl_protos::gc::Referee_Stage value);

  // @@protoc_insertion_point(class_scope:ssl_protos.gc.ChangeStage)
 private:
  void set_has_new_stage();
  void clear_has_new_stage();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int new_stage_;
  friend struct ::protobuf_gc_5fchange_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SetBallPlacementPos : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ssl_protos.gc.SetBallPlacementPos) */ {
 public:
  SetBallPlacementPos();
  virtual ~SetBallPlacementPos();

  SetBallPlacementPos(const SetBallPlacementPos& from);

  inline SetBallPlacementPos& operator=(const SetBallPlacementPos& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetBallPlacementPos(SetBallPlacementPos&& from) noexcept
    : SetBallPlacementPos() {
    *this = ::std::move(from);
  }

  inline SetBallPlacementPos& operator=(SetBallPlacementPos&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetBallPlacementPos& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetBallPlacementPos* internal_default_instance() {
    return reinterpret_cast<const SetBallPlacementPos*>(
               &_SetBallPlacementPos_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(SetBallPlacementPos* other);
  friend void swap(SetBallPlacementPos& a, SetBallPlacementPos& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetBallPlacementPos* New() const final {
    return CreateMaybeMessage<SetBallPlacementPos>(NULL);
  }

  SetBallPlacementPos* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SetBallPlacementPos>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SetBallPlacementPos& from);
  void MergeFrom(const SetBallPlacementPos& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetBallPlacementPos* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ssl_protos.gc.Vector2 pos = 1;
  bool has_pos() const;
  void clear_pos();
  static const int kPosFieldNumber = 1;
  private:
  const ::ssl_protos::gc::Vector2& _internal_pos() const;
  public:
  const ::ssl_protos::gc::Vector2& pos() const;
  ::ssl_protos::gc::Vector2* release_pos();
  ::ssl_protos::gc::Vector2* mutable_pos();
  void set_allocated_pos(::ssl_protos::gc::Vector2* pos);

  // @@protoc_insertion_point(class_scope:ssl_protos.gc.SetBallPlacementPos)
 private:
  void set_has_pos();
  void clear_has_pos();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ssl_protos::gc::Vector2* pos_;
  friend struct ::protobuf_gc_5fchange_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AddYellowCard : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ssl_protos.gc.AddYellowCard) */ {
 public:
  AddYellowCard();
  virtual ~AddYellowCard();

  AddYellowCard(const AddYellowCard& from);

  inline AddYellowCard& operator=(const AddYellowCard& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddYellowCard(AddYellowCard&& from) noexcept
    : AddYellowCard() {
    *this = ::std::move(from);
  }

  inline AddYellowCard& operator=(AddYellowCard&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AddYellowCard& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddYellowCard* internal_default_instance() {
    return reinterpret_cast<const AddYellowCard*>(
               &_AddYellowCard_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(AddYellowCard* other);
  friend void swap(AddYellowCard& a, AddYellowCard& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddYellowCard* New() const final {
    return CreateMaybeMessage<AddYellowCard>(NULL);
  }

  AddYellowCard* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AddYellowCard>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AddYellowCard& from);
  void MergeFrom(const AddYellowCard& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddYellowCard* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ssl_protos.gc.GameEvent caused_by_game_event = 2;
  bool has_caused_by_game_event() const;
  void clear_caused_by_game_event();
  static const int kCausedByGameEventFieldNumber = 2;
  private:
  const ::ssl_protos::gc::GameEvent& _internal_caused_by_game_event() const;
  public:
  const ::ssl_protos::gc::GameEvent& caused_by_game_event() const;
  ::ssl_protos::gc::GameEvent* release_caused_by_game_event();
  ::ssl_protos::gc::GameEvent* mutable_caused_by_game_event();
  void set_allocated_caused_by_game_event(::ssl_protos::gc::GameEvent* caused_by_game_event);

  // optional .ssl_protos.gc.Team for_team = 1;
  bool has_for_team() const;
  void clear_for_team();
  static const int kForTeamFieldNumber = 1;
  ::ssl_protos::gc::Team for_team() const;
  void set_for_team(::ssl_protos::gc::Team value);

  // @@protoc_insertion_point(class_scope:ssl_protos.gc.AddYellowCard)
 private:
  void set_has_for_team();
  void clear_has_for_team();
  void set_has_caused_by_game_event();
  void clear_has_caused_by_game_event();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ssl_protos::gc::GameEvent* caused_by_game_event_;
  int for_team_;
  friend struct ::protobuf_gc_5fchange_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AddRedCard : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ssl_protos.gc.AddRedCard) */ {
 public:
  AddRedCard();
  virtual ~AddRedCard();

  AddRedCard(const AddRedCard& from);

  inline AddRedCard& operator=(const AddRedCard& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddRedCard(AddRedCard&& from) noexcept
    : AddRedCard() {
    *this = ::std::move(from);
  }

  inline AddRedCard& operator=(AddRedCard&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AddRedCard& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddRedCard* internal_default_instance() {
    return reinterpret_cast<const AddRedCard*>(
               &_AddRedCard_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(AddRedCard* other);
  friend void swap(AddRedCard& a, AddRedCard& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddRedCard* New() const final {
    return CreateMaybeMessage<AddRedCard>(NULL);
  }

  AddRedCard* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AddRedCard>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AddRedCard& from);
  void MergeFrom(const AddRedCard& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddRedCard* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ssl_protos.gc.GameEvent caused_by_game_event = 2;
  bool has_caused_by_game_event() const;
  void clear_caused_by_game_event();
  static const int kCausedByGameEventFieldNumber = 2;
  private:
  const ::ssl_protos::gc::GameEvent& _internal_caused_by_game_event() const;
  public:
  const ::ssl_protos::gc::GameEvent& caused_by_game_event() const;
  ::ssl_protos::gc::GameEvent* release_caused_by_game_event();
  ::ssl_protos::gc::GameEvent* mutable_caused_by_game_event();
  void set_allocated_caused_by_game_event(::ssl_protos::gc::GameEvent* caused_by_game_event);

  // optional .ssl_protos.gc.Team for_team = 1;
  bool has_for_team() const;
  void clear_for_team();
  static const int kForTeamFieldNumber = 1;
  ::ssl_protos::gc::Team for_team() const;
  void set_for_team(::ssl_protos::gc::Team value);

  // @@protoc_insertion_point(class_scope:ssl_protos.gc.AddRedCard)
 private:
  void set_has_for_team();
  void clear_has_for_team();
  void set_has_caused_by_game_event();
  void clear_has_caused_by_game_event();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ssl_protos::gc::GameEvent* caused_by_game_event_;
  int for_team_;
  friend struct ::protobuf_gc_5fchange_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class YellowCardOver : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ssl_protos.gc.YellowCardOver) */ {
 public:
  YellowCardOver();
  virtual ~YellowCardOver();

  YellowCardOver(const YellowCardOver& from);

  inline YellowCardOver& operator=(const YellowCardOver& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  YellowCardOver(YellowCardOver&& from) noexcept
    : YellowCardOver() {
    *this = ::std::move(from);
  }

  inline YellowCardOver& operator=(YellowCardOver&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YellowCardOver& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const YellowCardOver* internal_default_instance() {
    return reinterpret_cast<const YellowCardOver*>(
               &_YellowCardOver_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(YellowCardOver* other);
  friend void swap(YellowCardOver& a, YellowCardOver& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline YellowCardOver* New() const final {
    return CreateMaybeMessage<YellowCardOver>(NULL);
  }

  YellowCardOver* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<YellowCardOver>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const YellowCardOver& from);
  void MergeFrom(const YellowCardOver& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(YellowCardOver* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ssl_protos.gc.Team for_team = 1;
  bool has_for_team() const;
  void clear_for_team();
  static const int kForTeamFieldNumber = 1;
  ::ssl_protos::gc::Team for_team() const;
  void set_for_team(::ssl_protos::gc::Team value);

  // @@protoc_insertion_point(class_scope:ssl_protos.gc.YellowCardOver)
 private:
  void set_has_for_team();
  void clear_has_for_team();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int for_team_;
  friend struct ::protobuf_gc_5fchange_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AddGameEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ssl_protos.gc.AddGameEvent) */ {
 public:
  AddGameEvent();
  virtual ~AddGameEvent();

  AddGameEvent(const AddGameEvent& from);

  inline AddGameEvent& operator=(const AddGameEvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddGameEvent(AddGameEvent&& from) noexcept
    : AddGameEvent() {
    *this = ::std::move(from);
  }

  inline AddGameEvent& operator=(AddGameEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AddGameEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddGameEvent* internal_default_instance() {
    return reinterpret_cast<const AddGameEvent*>(
               &_AddGameEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(AddGameEvent* other);
  friend void swap(AddGameEvent& a, AddGameEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddGameEvent* New() const final {
    return CreateMaybeMessage<AddGameEvent>(NULL);
  }

  AddGameEvent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AddGameEvent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AddGameEvent& from);
  void MergeFrom(const AddGameEvent& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddGameEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ssl_protos.gc.GameEvent game_event = 1;
  bool has_game_event() const;
  void clear_game_event();
  static const int kGameEventFieldNumber = 1;
  private:
  const ::ssl_protos::gc::GameEvent& _internal_game_event() const;
  public:
  const ::ssl_protos::gc::GameEvent& game_event() const;
  ::ssl_protos::gc::GameEvent* release_game_event();
  ::ssl_protos::gc::GameEvent* mutable_game_event();
  void set_allocated_game_event(::ssl_protos::gc::GameEvent* game_event);

  // @@protoc_insertion_point(class_scope:ssl_protos.gc.AddGameEvent)
 private:
  void set_has_game_event();
  void clear_has_game_event();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ssl_protos::gc::GameEvent* game_event_;
  friend struct ::protobuf_gc_5fchange_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AddPassiveGameEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ssl_protos.gc.AddPassiveGameEvent) */ {
 public:
  AddPassiveGameEvent();
  virtual ~AddPassiveGameEvent();

  AddPassiveGameEvent(const AddPassiveGameEvent& from);

  inline AddPassiveGameEvent& operator=(const AddPassiveGameEvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddPassiveGameEvent(AddPassiveGameEvent&& from) noexcept
    : AddPassiveGameEvent() {
    *this = ::std::move(from);
  }

  inline AddPassiveGameEvent& operator=(AddPassiveGameEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AddPassiveGameEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddPassiveGameEvent* internal_default_instance() {
    return reinterpret_cast<const AddPassiveGameEvent*>(
               &_AddPassiveGameEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(AddPassiveGameEvent* other);
  friend void swap(AddPassiveGameEvent& a, AddPassiveGameEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddPassiveGameEvent* New() const final {
    return CreateMaybeMessage<AddPassiveGameEvent>(NULL);
  }

  AddPassiveGameEvent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AddPassiveGameEvent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AddPassiveGameEvent& from);
  void MergeFrom(const AddPassiveGameEvent& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddPassiveGameEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ssl_protos.gc.GameEvent game_event = 1;
  bool has_game_event() const;
  void clear_game_event();
  static const int kGameEventFieldNumber = 1;
  private:
  const ::ssl_protos::gc::GameEvent& _internal_game_event() const;
  public:
  const ::ssl_protos::gc::GameEvent& game_event() const;
  ::ssl_protos::gc::GameEvent* release_game_event();
  ::ssl_protos::gc::GameEvent* mutable_game_event();
  void set_allocated_game_event(::ssl_protos::gc::GameEvent* game_event);

  // @@protoc_insertion_point(class_scope:ssl_protos.gc.AddPassiveGameEvent)
 private:
  void set_has_game_event();
  void clear_has_game_event();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ssl_protos::gc::GameEvent* game_event_;
  friend struct ::protobuf_gc_5fchange_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AddProposal : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ssl_protos.gc.AddProposal) */ {
 public:
  AddProposal();
  virtual ~AddProposal();

  AddProposal(const AddProposal& from);

  inline AddProposal& operator=(const AddProposal& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddProposal(AddProposal&& from) noexcept
    : AddProposal() {
    *this = ::std::move(from);
  }

  inline AddProposal& operator=(AddProposal&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AddProposal& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddProposal* internal_default_instance() {
    return reinterpret_cast<const AddProposal*>(
               &_AddProposal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(AddProposal* other);
  friend void swap(AddProposal& a, AddProposal& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddProposal* New() const final {
    return CreateMaybeMessage<AddProposal>(NULL);
  }

  AddProposal* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AddProposal>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AddProposal& from);
  void MergeFrom(const AddProposal& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddProposal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ssl_protos.gc.Proposal proposal = 1;
  bool has_proposal() const;
  void clear_proposal();
  static const int kProposalFieldNumber = 1;
  private:
  const ::ssl_protos::gc::Proposal& _internal_proposal() const;
  public:
  const ::ssl_protos::gc::Proposal& proposal() const;
  ::ssl_protos::gc::Proposal* release_proposal();
  ::ssl_protos::gc::Proposal* mutable_proposal();
  void set_allocated_proposal(::ssl_protos::gc::Proposal* proposal);

  // @@protoc_insertion_point(class_scope:ssl_protos.gc.AddProposal)
 private:
  void set_has_proposal();
  void clear_has_proposal();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ssl_protos::gc::Proposal* proposal_;
  friend struct ::protobuf_gc_5fchange_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AcceptProposalGroup : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ssl_protos.gc.AcceptProposalGroup) */ {
 public:
  AcceptProposalGroup();
  virtual ~AcceptProposalGroup();

  AcceptProposalGroup(const AcceptProposalGroup& from);

  inline AcceptProposalGroup& operator=(const AcceptProposalGroup& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AcceptProposalGroup(AcceptProposalGroup&& from) noexcept
    : AcceptProposalGroup() {
    *this = ::std::move(from);
  }

  inline AcceptProposalGroup& operator=(AcceptProposalGroup&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AcceptProposalGroup& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AcceptProposalGroup* internal_default_instance() {
    return reinterpret_cast<const AcceptProposalGroup*>(
               &_AcceptProposalGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(AcceptProposalGroup* other);
  friend void swap(AcceptProposalGroup& a, AcceptProposalGroup& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AcceptProposalGroup* New() const final {
    return CreateMaybeMessage<AcceptProposalGroup>(NULL);
  }

  AcceptProposalGroup* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AcceptProposalGroup>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AcceptProposalGroup& from);
  void MergeFrom(const AcceptProposalGroup& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AcceptProposalGroup* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string accepted_by = 2;
  bool has_accepted_by() const;
  void clear_accepted_by();
  static const int kAcceptedByFieldNumber = 2;
  const ::std::string& accepted_by() const;
  void set_accepted_by(const ::std::string& value);
  #if LANG_CXX11
  void set_accepted_by(::std::string&& value);
  #endif
  void set_accepted_by(const char* value);
  void set_accepted_by(const char* value, size_t size);
  ::std::string* mutable_accepted_by();
  ::std::string* release_accepted_by();
  void set_allocated_accepted_by(::std::string* accepted_by);

  // optional uint32 group_id = 1;
  bool has_group_id() const;
  void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  ::google::protobuf::uint32 group_id() const;
  void set_group_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ssl_protos.gc.AcceptProposalGroup)
 private:
  void set_has_group_id();
  void clear_has_group_id();
  void set_has_accepted_by();
  void clear_has_accepted_by();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr accepted_by_;
  ::google::protobuf::uint32 group_id_;
  friend struct ::protobuf_gc_5fchange_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StartBallPlacement : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ssl_protos.gc.StartBallPlacement) */ {
 public:
  StartBallPlacement();
  virtual ~StartBallPlacement();

  StartBallPlacement(const StartBallPlacement& from);

  inline StartBallPlacement& operator=(const StartBallPlacement& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StartBallPlacement(StartBallPlacement&& from) noexcept
    : StartBallPlacement() {
    *this = ::std::move(from);
  }

  inline StartBallPlacement& operator=(StartBallPlacement&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StartBallPlacement& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StartBallPlacement* internal_default_instance() {
    return reinterpret_cast<const StartBallPlacement*>(
               &_StartBallPlacement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(StartBallPlacement* other);
  friend void swap(StartBallPlacement& a, StartBallPlacement& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StartBallPlacement* New() const final {
    return CreateMaybeMessage<StartBallPlacement>(NULL);
  }

  StartBallPlacement* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StartBallPlacement>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StartBallPlacement& from);
  void MergeFrom(const StartBallPlacement& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartBallPlacement* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ssl_protos.gc.StartBallPlacement)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_gc_5fchange_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Continue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ssl_protos.gc.Continue) */ {
 public:
  Continue();
  virtual ~Continue();

  Continue(const Continue& from);

  inline Continue& operator=(const Continue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Continue(Continue&& from) noexcept
    : Continue() {
    *this = ::std::move(from);
  }

  inline Continue& operator=(Continue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Continue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Continue* internal_default_instance() {
    return reinterpret_cast<const Continue*>(
               &_Continue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(Continue* other);
  friend void swap(Continue& a, Continue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Continue* New() const final {
    return CreateMaybeMessage<Continue>(NULL);
  }

  Continue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Continue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Continue& from);
  void MergeFrom(const Continue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Continue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ssl_protos.gc.Continue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_gc_5fchange_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UpdateConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ssl_protos.gc.UpdateConfig) */ {
 public:
  UpdateConfig();
  virtual ~UpdateConfig();

  UpdateConfig(const UpdateConfig& from);

  inline UpdateConfig& operator=(const UpdateConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UpdateConfig(UpdateConfig&& from) noexcept
    : UpdateConfig() {
    *this = ::std::move(from);
  }

  inline UpdateConfig& operator=(UpdateConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateConfig* internal_default_instance() {
    return reinterpret_cast<const UpdateConfig*>(
               &_UpdateConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(UpdateConfig* other);
  friend void swap(UpdateConfig& a, UpdateConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpdateConfig* New() const final {
    return CreateMaybeMessage<UpdateConfig>(NULL);
  }

  UpdateConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UpdateConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UpdateConfig& from);
  void MergeFrom(const UpdateConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ssl_protos.gc.Division division = 1;
  bool has_division() const;
  void clear_division();
  static const int kDivisionFieldNumber = 1;
  ::ssl_protos::gc::Division division() const;
  void set_division(::ssl_protos::gc::Division value);

  // optional .ssl_protos.gc.Team first_kickoff_team = 2;
  bool has_first_kickoff_team() const;
  void clear_first_kickoff_team();
  static const int kFirstKickoffTeamFieldNumber = 2;
  ::ssl_protos::gc::Team first_kickoff_team() const;
  void set_first_kickoff_team(::ssl_protos::gc::Team value);

  // optional bool auto_continue = 3;
  bool has_auto_continue() const;
  void clear_auto_continue();
  static const int kAutoContinueFieldNumber = 3;
  bool auto_continue() const;
  void set_auto_continue(bool value);

  // @@protoc_insertion_point(class_scope:ssl_protos.gc.UpdateConfig)
 private:
  void set_has_division();
  void clear_has_division();
  void set_has_first_kickoff_team();
  void clear_has_first_kickoff_team();
  void set_has_auto_continue();
  void clear_has_auto_continue();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int division_;
  int first_kickoff_team_;
  bool auto_continue_;
  friend struct ::protobuf_gc_5fchange_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UpdateTeamState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ssl_protos.gc.UpdateTeamState) */ {
 public:
  UpdateTeamState();
  virtual ~UpdateTeamState();

  UpdateTeamState(const UpdateTeamState& from);

  inline UpdateTeamState& operator=(const UpdateTeamState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UpdateTeamState(UpdateTeamState&& from) noexcept
    : UpdateTeamState() {
    *this = ::std::move(from);
  }

  inline UpdateTeamState& operator=(UpdateTeamState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateTeamState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateTeamState* internal_default_instance() {
    return reinterpret_cast<const UpdateTeamState*>(
               &_UpdateTeamState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(UpdateTeamState* other);
  friend void swap(UpdateTeamState& a, UpdateTeamState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpdateTeamState* New() const final {
    return CreateMaybeMessage<UpdateTeamState>(NULL);
  }

  UpdateTeamState* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UpdateTeamState>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UpdateTeamState& from);
  void MergeFrom(const UpdateTeamState& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateTeamState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string team_name = 2;
  bool has_team_name() const;
  void clear_team_name();
  static const int kTeamNameFieldNumber = 2;
  const ::std::string& team_name() const;
  void set_team_name(const ::std::string& value);
  #if LANG_CXX11
  void set_team_name(::std::string&& value);
  #endif
  void set_team_name(const char* value);
  void set_team_name(const char* value, size_t size);
  ::std::string* mutable_team_name();
  ::std::string* release_team_name();
  void set_allocated_team_name(::std::string* team_name);

  // optional string timeout_time_left = 6;
  bool has_timeout_time_left() const;
  void clear_timeout_time_left();
  static const int kTimeoutTimeLeftFieldNumber = 6;
  const ::std::string& timeout_time_left() const;
  void set_timeout_time_left(const ::std::string& value);
  #if LANG_CXX11
  void set_timeout_time_left(::std::string&& value);
  #endif
  void set_timeout_time_left(const char* value);
  void set_timeout_time_left(const char* value, size_t size);
  ::std::string* mutable_timeout_time_left();
  ::std::string* release_timeout_time_left();
  void set_allocated_timeout_time_left(::std::string* timeout_time_left);

  // optional .ssl_protos.gc.RedCard red_card = 12;
  bool has_red_card() const;
  void clear_red_card();
  static const int kRedCardFieldNumber = 12;
  private:
  const ::ssl_protos::gc::RedCard& _internal_red_card() const;
  public:
  const ::ssl_protos::gc::RedCard& red_card() const;
  ::ssl_protos::gc::RedCard* release_red_card();
  ::ssl_protos::gc::RedCard* mutable_red_card();
  void set_allocated_red_card(::ssl_protos::gc::RedCard* red_card);

  // optional .ssl_protos.gc.Foul foul = 13;
  bool has_foul() const;
  void clear_foul();
  static const int kFoulFieldNumber = 13;
  private:
  const ::ssl_protos::gc::Foul& _internal_foul() const;
  public:
  const ::ssl_protos::gc::Foul& foul() const;
  ::ssl_protos::gc::Foul* release_foul();
  ::ssl_protos::gc::Foul* mutable_foul();
  void set_allocated_foul(::ssl_protos::gc::Foul* foul);

  // optional .ssl_protos.gc.YellowCard yellow_card = 20;
  bool has_yellow_card() const;
  void clear_yellow_card();
  static const int kYellowCardFieldNumber = 20;
  private:
  const ::ssl_protos::gc::YellowCard& _internal_yellow_card() const;
  public:
  const ::ssl_protos::gc::YellowCard& yellow_card() const;
  ::ssl_protos::gc::YellowCard* release_yellow_card();
  ::ssl_protos::gc::YellowCard* mutable_yellow_card();
  void set_allocated_yellow_card(::ssl_protos::gc::YellowCard* yellow_card);

  // optional .ssl_protos.gc.Team for_team = 1;
  bool has_for_team() const;
  void clear_for_team();
  static const int kForTeamFieldNumber = 1;
  ::ssl_protos::gc::Team for_team() const;
  void set_for_team(::ssl_protos::gc::Team value);

  // optional int32 goals = 3;
  bool has_goals() const;
  void clear_goals();
  static const int kGoalsFieldNumber = 3;
  ::google::protobuf::int32 goals() const;
  void set_goals(::google::protobuf::int32 value);

  // optional int32 goalkeeper = 4;
  bool has_goalkeeper() const;
  void clear_goalkeeper();
  static const int kGoalkeeperFieldNumber = 4;
  ::google::protobuf::int32 goalkeeper() const;
  void set_goalkeeper(::google::protobuf::int32 value);

  // optional int32 timeouts_left = 5;
  bool has_timeouts_left() const;
  void clear_timeouts_left();
  static const int kTimeoutsLeftFieldNumber = 5;
  ::google::protobuf::int32 timeouts_left() const;
  void set_timeouts_left(::google::protobuf::int32 value);

  // optional int32 ball_placement_failures = 8;
  bool has_ball_placement_failures() const;
  void clear_ball_placement_failures();
  static const int kBallPlacementFailuresFieldNumber = 8;
  ::google::protobuf::int32 ball_placement_failures() const;
  void set_ball_placement_failures(::google::protobuf::int32 value);

  // optional bool on_positive_half = 7;
  bool has_on_positive_half() const;
  void clear_on_positive_half();
  static const int kOnPositiveHalfFieldNumber = 7;
  bool on_positive_half() const;
  void set_on_positive_half(bool value);

  // optional bool can_place_ball = 9;
  bool has_can_place_ball() const;
  void clear_can_place_ball();
  static const int kCanPlaceBallFieldNumber = 9;
  bool can_place_ball() const;
  void set_can_place_ball(bool value);

  // optional bool requests_bot_substitution = 10;
  bool has_requests_bot_substitution() const;
  void clear_requests_bot_substitution();
  static const int kRequestsBotSubstitutionFieldNumber = 10;
  bool requests_bot_substitution() const;
  void set_requests_bot_substitution(bool value);

  // optional bool requests_timeout = 17;
  bool has_requests_timeout() const;
  void clear_requests_timeout();
  static const int kRequestsTimeoutFieldNumber = 17;
  bool requests_timeout() const;
  void set_requests_timeout(bool value);

  // optional uint32 remove_yellow_card = 14;
  bool has_remove_yellow_card() const;
  void clear_remove_yellow_card();
  static const int kRemoveYellowCardFieldNumber = 14;
  ::google::protobuf::uint32 remove_yellow_card() const;
  void set_remove_yellow_card(::google::protobuf::uint32 value);

  // optional uint32 remove_red_card = 15;
  bool has_remove_red_card() const;
  void clear_remove_red_card();
  static const int kRemoveRedCardFieldNumber = 15;
  ::google::protobuf::uint32 remove_red_card() const;
  void set_remove_red_card(::google::protobuf::uint32 value);

  // optional uint32 remove_foul = 16;
  bool has_remove_foul() const;
  void clear_remove_foul();
  static const int kRemoveFoulFieldNumber = 16;
  ::google::protobuf::uint32 remove_foul() const;
  void set_remove_foul(::google::protobuf::uint32 value);

  // optional bool requests_challenge = 18;
  bool has_requests_challenge() const;
  void clear_requests_challenge();
  static const int kRequestsChallengeFieldNumber = 18;
  bool requests_challenge() const;
  void set_requests_challenge(bool value);

  // optional bool requests_emergency_stop = 19;
  bool has_requests_emergency_stop() const;
  void clear_requests_emergency_stop();
  static const int kRequestsEmergencyStopFieldNumber = 19;
  bool requests_emergency_stop() const;
  void set_requests_emergency_stop(bool value);

  // optional int32 challenge_flags_left = 21;
  bool has_challenge_flags_left() const;
  void clear_challenge_flags_left();
  static const int kChallengeFlagsLeftFieldNumber = 21;
  ::google::protobuf::int32 challenge_flags_left() const;
  void set_challenge_flags_left(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ssl_protos.gc.UpdateTeamState)
 private:
  void set_has_for_team();
  void clear_has_for_team();
  void set_has_team_name();
  void clear_has_team_name();
  void set_has_goals();
  void clear_has_goals();
  void set_has_goalkeeper();
  void clear_has_goalkeeper();
  void set_has_timeouts_left();
  void clear_has_timeouts_left();
  void set_has_timeout_time_left();
  void clear_has_timeout_time_left();
  void set_has_on_positive_half();
  void clear_has_on_positive_half();
  void set_has_ball_placement_failures();
  void clear_has_ball_placement_failures();
  void set_has_can_place_ball();
  void clear_has_can_place_ball();
  void set_has_challenge_flags_left();
  void clear_has_challenge_flags_left();
  void set_has_requests_bot_substitution();
  void clear_has_requests_bot_substitution();
  void set_has_requests_timeout();
  void clear_has_requests_timeout();
  void set_has_requests_challenge();
  void clear_has_requests_challenge();
  void set_has_requests_emergency_stop();
  void clear_has_requests_emergency_stop();
  void set_has_yellow_card();
  void clear_has_yellow_card();
  void set_has_red_card();
  void clear_has_red_card();
  void set_has_foul();
  void clear_has_foul();
  void set_has_remove_yellow_card();
  void clear_has_remove_yellow_card();
  void set_has_remove_red_card();
  void clear_has_remove_red_card();
  void set_has_remove_foul();
  void clear_has_remove_foul();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr team_name_;
  ::google::protobuf::internal::ArenaStringPtr timeout_time_left_;
  ::ssl_protos::gc::RedCard* red_card_;
  ::ssl_protos::gc::Foul* foul_;
  ::ssl_protos::gc::YellowCard* yellow_card_;
  int for_team_;
  ::google::protobuf::int32 goals_;
  ::google::protobuf::int32 goalkeeper_;
  ::google::protobuf::int32 timeouts_left_;
  ::google::protobuf::int32 ball_placement_failures_;
  bool on_positive_half_;
  bool can_place_ball_;
  bool requests_bot_substitution_;
  bool requests_timeout_;
  ::google::protobuf::uint32 remove_yellow_card_;
  ::google::protobuf::uint32 remove_red_card_;
  ::google::protobuf::uint32 remove_foul_;
  bool requests_challenge_;
  bool requests_emergency_stop_;
  ::google::protobuf::int32 challenge_flags_left_;
  friend struct ::protobuf_gc_5fchange_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SwitchColors : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ssl_protos.gc.SwitchColors) */ {
 public:
  SwitchColors();
  virtual ~SwitchColors();

  SwitchColors(const SwitchColors& from);

  inline SwitchColors& operator=(const SwitchColors& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SwitchColors(SwitchColors&& from) noexcept
    : SwitchColors() {
    *this = ::std::move(from);
  }

  inline SwitchColors& operator=(SwitchColors&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SwitchColors& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SwitchColors* internal_default_instance() {
    return reinterpret_cast<const SwitchColors*>(
               &_SwitchColors_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(SwitchColors* other);
  friend void swap(SwitchColors& a, SwitchColors& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SwitchColors* New() const final {
    return CreateMaybeMessage<SwitchColors>(NULL);
  }

  SwitchColors* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SwitchColors>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SwitchColors& from);
  void MergeFrom(const SwitchColors& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwitchColors* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ssl_protos.gc.SwitchColors)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_gc_5fchange_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Revert : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ssl_protos.gc.Revert) */ {
 public:
  Revert();
  virtual ~Revert();

  Revert(const Revert& from);

  inline Revert& operator=(const Revert& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Revert(Revert&& from) noexcept
    : Revert() {
    *this = ::std::move(from);
  }

  inline Revert& operator=(Revert&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Revert& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Revert* internal_default_instance() {
    return reinterpret_cast<const Revert*>(
               &_Revert_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(Revert* other);
  friend void swap(Revert& a, Revert& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Revert* New() const final {
    return CreateMaybeMessage<Revert>(NULL);
  }

  Revert* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Revert>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Revert& from);
  void MergeFrom(const Revert& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Revert* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 change_id = 1;
  bool has_change_id() const;
  void clear_change_id();
  static const int kChangeIdFieldNumber = 1;
  ::google::protobuf::int32 change_id() const;
  void set_change_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ssl_protos.gc.Revert)
 private:
  void set_has_change_id();
  void clear_has_change_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 change_id_;
  friend struct ::protobuf_gc_5fchange_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NewGameState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ssl_protos.gc.NewGameState) */ {
 public:
  NewGameState();
  virtual ~NewGameState();

  NewGameState(const NewGameState& from);

  inline NewGameState& operator=(const NewGameState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NewGameState(NewGameState&& from) noexcept
    : NewGameState() {
    *this = ::std::move(from);
  }

  inline NewGameState& operator=(NewGameState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NewGameState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NewGameState* internal_default_instance() {
    return reinterpret_cast<const NewGameState*>(
               &_NewGameState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(NewGameState* other);
  friend void swap(NewGameState& a, NewGameState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NewGameState* New() const final {
    return CreateMaybeMessage<NewGameState>(NULL);
  }

  NewGameState* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NewGameState>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NewGameState& from);
  void MergeFrom(const NewGameState& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewGameState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ssl_protos.gc.GameState game_state = 1;
  bool has_game_state() const;
  void clear_game_state();
  static const int kGameStateFieldNumber = 1;
  private:
  const ::ssl_protos::gc::GameState& _internal_game_state() const;
  public:
  const ::ssl_protos::gc::GameState& game_state() const;
  ::ssl_protos::gc::GameState* release_game_state();
  ::ssl_protos::gc::GameState* mutable_game_state();
  void set_allocated_game_state(::ssl_protos::gc::GameState* game_state);

  // @@protoc_insertion_point(class_scope:ssl_protos.gc.NewGameState)
 private:
  void set_has_game_state();
  void clear_has_game_state();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ssl_protos::gc::GameState* game_state_;
  friend struct ::protobuf_gc_5fchange_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// StateChange

// optional int32 id = 1;
inline bool StateChange::has_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StateChange::set_has_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StateChange::clear_has_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StateChange::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 StateChange::id() const {
  // @@protoc_insertion_point(field_get:ssl_protos.gc.StateChange.id)
  return id_;
}
inline void StateChange::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:ssl_protos.gc.StateChange.id)
}

// optional .ssl_protos.gc.State state_pre = 2;
inline bool StateChange::has_state_pre() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StateChange::set_has_state_pre() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StateChange::clear_has_state_pre() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ssl_protos::gc::State& StateChange::_internal_state_pre() const {
  return *state_pre_;
}
inline const ::ssl_protos::gc::State& StateChange::state_pre() const {
  const ::ssl_protos::gc::State* p = state_pre_;
  // @@protoc_insertion_point(field_get:ssl_protos.gc.StateChange.state_pre)
  return p != NULL ? *p : *reinterpret_cast<const ::ssl_protos::gc::State*>(
      &::ssl_protos::gc::_State_default_instance_);
}
inline ::ssl_protos::gc::State* StateChange::release_state_pre() {
  // @@protoc_insertion_point(field_release:ssl_protos.gc.StateChange.state_pre)
  clear_has_state_pre();
  ::ssl_protos::gc::State* temp = state_pre_;
  state_pre_ = NULL;
  return temp;
}
inline ::ssl_protos::gc::State* StateChange::mutable_state_pre() {
  set_has_state_pre();
  if (state_pre_ == NULL) {
    auto* p = CreateMaybeMessage<::ssl_protos::gc::State>(GetArenaNoVirtual());
    state_pre_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ssl_protos.gc.StateChange.state_pre)
  return state_pre_;
}
inline void StateChange::set_allocated_state_pre(::ssl_protos::gc::State* state_pre) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(state_pre_);
  }
  if (state_pre) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      state_pre = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, state_pre, submessage_arena);
    }
    set_has_state_pre();
  } else {
    clear_has_state_pre();
  }
  state_pre_ = state_pre;
  // @@protoc_insertion_point(field_set_allocated:ssl_protos.gc.StateChange.state_pre)
}

// optional .ssl_protos.gc.State state = 3;
inline bool StateChange::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StateChange::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StateChange::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ssl_protos::gc::State& StateChange::_internal_state() const {
  return *state_;
}
inline const ::ssl_protos::gc::State& StateChange::state() const {
  const ::ssl_protos::gc::State* p = state_;
  // @@protoc_insertion_point(field_get:ssl_protos.gc.StateChange.state)
  return p != NULL ? *p : *reinterpret_cast<const ::ssl_protos::gc::State*>(
      &::ssl_protos::gc::_State_default_instance_);
}
inline ::ssl_protos::gc::State* StateChange::release_state() {
  // @@protoc_insertion_point(field_release:ssl_protos.gc.StateChange.state)
  clear_has_state();
  ::ssl_protos::gc::State* temp = state_;
  state_ = NULL;
  return temp;
}
inline ::ssl_protos::gc::State* StateChange::mutable_state() {
  set_has_state();
  if (state_ == NULL) {
    auto* p = CreateMaybeMessage<::ssl_protos::gc::State>(GetArenaNoVirtual());
    state_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ssl_protos.gc.StateChange.state)
  return state_;
}
inline void StateChange::set_allocated_state(::ssl_protos::gc::State* state) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(state_);
  }
  if (state) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      state = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    set_has_state();
  } else {
    clear_has_state();
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:ssl_protos.gc.StateChange.state)
}

// optional .ssl_protos.gc.Change change = 4;
inline bool StateChange::has_change() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StateChange::set_has_change() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StateChange::clear_has_change() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StateChange::clear_change() {
  if (change_ != NULL) change_->Clear();
  clear_has_change();
}
inline const ::ssl_protos::gc::Change& StateChange::_internal_change() const {
  return *change_;
}
inline const ::ssl_protos::gc::Change& StateChange::change() const {
  const ::ssl_protos::gc::Change* p = change_;
  // @@protoc_insertion_point(field_get:ssl_protos.gc.StateChange.change)
  return p != NULL ? *p : *reinterpret_cast<const ::ssl_protos::gc::Change*>(
      &::ssl_protos::gc::_Change_default_instance_);
}
inline ::ssl_protos::gc::Change* StateChange::release_change() {
  // @@protoc_insertion_point(field_release:ssl_protos.gc.StateChange.change)
  clear_has_change();
  ::ssl_protos::gc::Change* temp = change_;
  change_ = NULL;
  return temp;
}
inline ::ssl_protos::gc::Change* StateChange::mutable_change() {
  set_has_change();
  if (change_ == NULL) {
    auto* p = CreateMaybeMessage<::ssl_protos::gc::Change>(GetArenaNoVirtual());
    change_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ssl_protos.gc.StateChange.change)
  return change_;
}
inline void StateChange::set_allocated_change(::ssl_protos::gc::Change* change) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete change_;
  }
  if (change) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      change = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, change, submessage_arena);
    }
    set_has_change();
  } else {
    clear_has_change();
  }
  change_ = change;
  // @@protoc_insertion_point(field_set_allocated:ssl_protos.gc.StateChange.change)
}

// optional .google.protobuf.Timestamp timestamp = 5;
inline bool StateChange::has_timestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StateChange::set_has_timestamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StateChange::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::google::protobuf::Timestamp& StateChange::_internal_timestamp() const {
  return *timestamp_;
}
inline const ::google::protobuf::Timestamp& StateChange::timestamp() const {
  const ::google::protobuf::Timestamp* p = timestamp_;
  // @@protoc_insertion_point(field_get:ssl_protos.gc.StateChange.timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* StateChange::release_timestamp() {
  // @@protoc_insertion_point(field_release:ssl_protos.gc.StateChange.timestamp)
  clear_has_timestamp();
  ::google::protobuf::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline ::google::protobuf::Timestamp* StateChange::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaNoVirtual());
    timestamp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ssl_protos.gc.StateChange.timestamp)
  return timestamp_;
}
inline void StateChange::set_allocated_timestamp(::google::protobuf::Timestamp* timestamp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(timestamp)->GetArena();
    if (message_arena != submessage_arena) {
      timestamp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    set_has_timestamp();
  } else {
    clear_has_timestamp();
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:ssl_protos.gc.StateChange.timestamp)
}

// -------------------------------------------------------------------

// Change

// optional string origin = 1;
inline bool Change::has_origin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Change::set_has_origin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Change::clear_has_origin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Change::clear_origin() {
  origin_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_origin();
}
inline const ::std::string& Change::origin() const {
  // @@protoc_insertion_point(field_get:ssl_protos.gc.Change.origin)
  return origin_.GetNoArena();
}
inline void Change::set_origin(const ::std::string& value) {
  set_has_origin();
  origin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ssl_protos.gc.Change.origin)
}
#if LANG_CXX11
inline void Change::set_origin(::std::string&& value) {
  set_has_origin();
  origin_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ssl_protos.gc.Change.origin)
}
#endif
inline void Change::set_origin(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_origin();
  origin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ssl_protos.gc.Change.origin)
}
inline void Change::set_origin(const char* value, size_t size) {
  set_has_origin();
  origin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ssl_protos.gc.Change.origin)
}
inline ::std::string* Change::mutable_origin() {
  set_has_origin();
  // @@protoc_insertion_point(field_mutable:ssl_protos.gc.Change.origin)
  return origin_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Change::release_origin() {
  // @@protoc_insertion_point(field_release:ssl_protos.gc.Change.origin)
  if (!has_origin()) {
    return NULL;
  }
  clear_has_origin();
  return origin_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Change::set_allocated_origin(::std::string* origin) {
  if (origin != NULL) {
    set_has_origin();
  } else {
    clear_has_origin();
  }
  origin_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), origin);
  // @@protoc_insertion_point(field_set_allocated:ssl_protos.gc.Change.origin)
}

// optional bool revertible = 16;
inline bool Change::has_revertible() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Change::set_has_revertible() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Change::clear_has_revertible() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Change::clear_revertible() {
  revertible_ = false;
  clear_has_revertible();
}
inline bool Change::revertible() const {
  // @@protoc_insertion_point(field_get:ssl_protos.gc.Change.revertible)
  return revertible_;
}
inline void Change::set_revertible(bool value) {
  set_has_revertible();
  revertible_ = value;
  // @@protoc_insertion_point(field_set:ssl_protos.gc.Change.revertible)
}

// optional .ssl_protos.gc.NewCommand new_command = 2;
inline bool Change::has_new_command() const {
  return change_case() == kNewCommand;
}
inline void Change::set_has_new_command() {
  _oneof_case_[0] = kNewCommand;
}
inline void Change::clear_new_command() {
  if (has_new_command()) {
    delete change_.new_command_;
    clear_has_change();
  }
}
inline const ::ssl_protos::gc::NewCommand& Change::_internal_new_command() const {
  return *change_.new_command_;
}
inline ::ssl_protos::gc::NewCommand* Change::release_new_command() {
  // @@protoc_insertion_point(field_release:ssl_protos.gc.Change.new_command)
  if (has_new_command()) {
    clear_has_change();
      ::ssl_protos::gc::NewCommand* temp = change_.new_command_;
    change_.new_command_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::ssl_protos::gc::NewCommand& Change::new_command() const {
  // @@protoc_insertion_point(field_get:ssl_protos.gc.Change.new_command)
  return has_new_command()
      ? *change_.new_command_
      : *reinterpret_cast< ::ssl_protos::gc::NewCommand*>(&::ssl_protos::gc::_NewCommand_default_instance_);
}
inline ::ssl_protos::gc::NewCommand* Change::mutable_new_command() {
  if (!has_new_command()) {
    clear_change();
    set_has_new_command();
    change_.new_command_ = CreateMaybeMessage< ::ssl_protos::gc::NewCommand >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ssl_protos.gc.Change.new_command)
  return change_.new_command_;
}

// optional .ssl_protos.gc.ChangeStage change_stage = 3;
inline bool Change::has_change_stage() const {
  return change_case() == kChangeStage;
}
inline void Change::set_has_change_stage() {
  _oneof_case_[0] = kChangeStage;
}
inline void Change::clear_change_stage() {
  if (has_change_stage()) {
    delete change_.change_stage_;
    clear_has_change();
  }
}
inline const ::ssl_protos::gc::ChangeStage& Change::_internal_change_stage() const {
  return *change_.change_stage_;
}
inline ::ssl_protos::gc::ChangeStage* Change::release_change_stage() {
  // @@protoc_insertion_point(field_release:ssl_protos.gc.Change.change_stage)
  if (has_change_stage()) {
    clear_has_change();
      ::ssl_protos::gc::ChangeStage* temp = change_.change_stage_;
    change_.change_stage_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::ssl_protos::gc::ChangeStage& Change::change_stage() const {
  // @@protoc_insertion_point(field_get:ssl_protos.gc.Change.change_stage)
  return has_change_stage()
      ? *change_.change_stage_
      : *reinterpret_cast< ::ssl_protos::gc::ChangeStage*>(&::ssl_protos::gc::_ChangeStage_default_instance_);
}
inline ::ssl_protos::gc::ChangeStage* Change::mutable_change_stage() {
  if (!has_change_stage()) {
    clear_change();
    set_has_change_stage();
    change_.change_stage_ = CreateMaybeMessage< ::ssl_protos::gc::ChangeStage >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ssl_protos.gc.Change.change_stage)
  return change_.change_stage_;
}

// optional .ssl_protos.gc.SetBallPlacementPos set_ball_placement_pos = 4;
inline bool Change::has_set_ball_placement_pos() const {
  return change_case() == kSetBallPlacementPos;
}
inline void Change::set_has_set_ball_placement_pos() {
  _oneof_case_[0] = kSetBallPlacementPos;
}
inline void Change::clear_set_ball_placement_pos() {
  if (has_set_ball_placement_pos()) {
    delete change_.set_ball_placement_pos_;
    clear_has_change();
  }
}
inline const ::ssl_protos::gc::SetBallPlacementPos& Change::_internal_set_ball_placement_pos() const {
  return *change_.set_ball_placement_pos_;
}
inline ::ssl_protos::gc::SetBallPlacementPos* Change::release_set_ball_placement_pos() {
  // @@protoc_insertion_point(field_release:ssl_protos.gc.Change.set_ball_placement_pos)
  if (has_set_ball_placement_pos()) {
    clear_has_change();
      ::ssl_protos::gc::SetBallPlacementPos* temp = change_.set_ball_placement_pos_;
    change_.set_ball_placement_pos_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::ssl_protos::gc::SetBallPlacementPos& Change::set_ball_placement_pos() const {
  // @@protoc_insertion_point(field_get:ssl_protos.gc.Change.set_ball_placement_pos)
  return has_set_ball_placement_pos()
      ? *change_.set_ball_placement_pos_
      : *reinterpret_cast< ::ssl_protos::gc::SetBallPlacementPos*>(&::ssl_protos::gc::_SetBallPlacementPos_default_instance_);
}
inline ::ssl_protos::gc::SetBallPlacementPos* Change::mutable_set_ball_placement_pos() {
  if (!has_set_ball_placement_pos()) {
    clear_change();
    set_has_set_ball_placement_pos();
    change_.set_ball_placement_pos_ = CreateMaybeMessage< ::ssl_protos::gc::SetBallPlacementPos >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ssl_protos.gc.Change.set_ball_placement_pos)
  return change_.set_ball_placement_pos_;
}

// optional .ssl_protos.gc.AddYellowCard add_yellow_card = 5;
inline bool Change::has_add_yellow_card() const {
  return change_case() == kAddYellowCard;
}
inline void Change::set_has_add_yellow_card() {
  _oneof_case_[0] = kAddYellowCard;
}
inline void Change::clear_add_yellow_card() {
  if (has_add_yellow_card()) {
    delete change_.add_yellow_card_;
    clear_has_change();
  }
}
inline const ::ssl_protos::gc::AddYellowCard& Change::_internal_add_yellow_card() const {
  return *change_.add_yellow_card_;
}
inline ::ssl_protos::gc::AddYellowCard* Change::release_add_yellow_card() {
  // @@protoc_insertion_point(field_release:ssl_protos.gc.Change.add_yellow_card)
  if (has_add_yellow_card()) {
    clear_has_change();
      ::ssl_protos::gc::AddYellowCard* temp = change_.add_yellow_card_;
    change_.add_yellow_card_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::ssl_protos::gc::AddYellowCard& Change::add_yellow_card() const {
  // @@protoc_insertion_point(field_get:ssl_protos.gc.Change.add_yellow_card)
  return has_add_yellow_card()
      ? *change_.add_yellow_card_
      : *reinterpret_cast< ::ssl_protos::gc::AddYellowCard*>(&::ssl_protos::gc::_AddYellowCard_default_instance_);
}
inline ::ssl_protos::gc::AddYellowCard* Change::mutable_add_yellow_card() {
  if (!has_add_yellow_card()) {
    clear_change();
    set_has_add_yellow_card();
    change_.add_yellow_card_ = CreateMaybeMessage< ::ssl_protos::gc::AddYellowCard >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ssl_protos.gc.Change.add_yellow_card)
  return change_.add_yellow_card_;
}

// optional .ssl_protos.gc.AddRedCard add_red_card = 6;
inline bool Change::has_add_red_card() const {
  return change_case() == kAddRedCard;
}
inline void Change::set_has_add_red_card() {
  _oneof_case_[0] = kAddRedCard;
}
inline void Change::clear_add_red_card() {
  if (has_add_red_card()) {
    delete change_.add_red_card_;
    clear_has_change();
  }
}
inline const ::ssl_protos::gc::AddRedCard& Change::_internal_add_red_card() const {
  return *change_.add_red_card_;
}
inline ::ssl_protos::gc::AddRedCard* Change::release_add_red_card() {
  // @@protoc_insertion_point(field_release:ssl_protos.gc.Change.add_red_card)
  if (has_add_red_card()) {
    clear_has_change();
      ::ssl_protos::gc::AddRedCard* temp = change_.add_red_card_;
    change_.add_red_card_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::ssl_protos::gc::AddRedCard& Change::add_red_card() const {
  // @@protoc_insertion_point(field_get:ssl_protos.gc.Change.add_red_card)
  return has_add_red_card()
      ? *change_.add_red_card_
      : *reinterpret_cast< ::ssl_protos::gc::AddRedCard*>(&::ssl_protos::gc::_AddRedCard_default_instance_);
}
inline ::ssl_protos::gc::AddRedCard* Change::mutable_add_red_card() {
  if (!has_add_red_card()) {
    clear_change();
    set_has_add_red_card();
    change_.add_red_card_ = CreateMaybeMessage< ::ssl_protos::gc::AddRedCard >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ssl_protos.gc.Change.add_red_card)
  return change_.add_red_card_;
}

// optional .ssl_protos.gc.YellowCardOver yellow_card_over = 7;
inline bool Change::has_yellow_card_over() const {
  return change_case() == kYellowCardOver;
}
inline void Change::set_has_yellow_card_over() {
  _oneof_case_[0] = kYellowCardOver;
}
inline void Change::clear_yellow_card_over() {
  if (has_yellow_card_over()) {
    delete change_.yellow_card_over_;
    clear_has_change();
  }
}
inline const ::ssl_protos::gc::YellowCardOver& Change::_internal_yellow_card_over() const {
  return *change_.yellow_card_over_;
}
inline ::ssl_protos::gc::YellowCardOver* Change::release_yellow_card_over() {
  // @@protoc_insertion_point(field_release:ssl_protos.gc.Change.yellow_card_over)
  if (has_yellow_card_over()) {
    clear_has_change();
      ::ssl_protos::gc::YellowCardOver* temp = change_.yellow_card_over_;
    change_.yellow_card_over_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::ssl_protos::gc::YellowCardOver& Change::yellow_card_over() const {
  // @@protoc_insertion_point(field_get:ssl_protos.gc.Change.yellow_card_over)
  return has_yellow_card_over()
      ? *change_.yellow_card_over_
      : *reinterpret_cast< ::ssl_protos::gc::YellowCardOver*>(&::ssl_protos::gc::_YellowCardOver_default_instance_);
}
inline ::ssl_protos::gc::YellowCardOver* Change::mutable_yellow_card_over() {
  if (!has_yellow_card_over()) {
    clear_change();
    set_has_yellow_card_over();
    change_.yellow_card_over_ = CreateMaybeMessage< ::ssl_protos::gc::YellowCardOver >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ssl_protos.gc.Change.yellow_card_over)
  return change_.yellow_card_over_;
}

// optional .ssl_protos.gc.AddGameEvent add_game_event = 8;
inline bool Change::has_add_game_event() const {
  return change_case() == kAddGameEvent;
}
inline void Change::set_has_add_game_event() {
  _oneof_case_[0] = kAddGameEvent;
}
inline void Change::clear_add_game_event() {
  if (has_add_game_event()) {
    delete change_.add_game_event_;
    clear_has_change();
  }
}
inline const ::ssl_protos::gc::AddGameEvent& Change::_internal_add_game_event() const {
  return *change_.add_game_event_;
}
inline ::ssl_protos::gc::AddGameEvent* Change::release_add_game_event() {
  // @@protoc_insertion_point(field_release:ssl_protos.gc.Change.add_game_event)
  if (has_add_game_event()) {
    clear_has_change();
      ::ssl_protos::gc::AddGameEvent* temp = change_.add_game_event_;
    change_.add_game_event_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::ssl_protos::gc::AddGameEvent& Change::add_game_event() const {
  // @@protoc_insertion_point(field_get:ssl_protos.gc.Change.add_game_event)
  return has_add_game_event()
      ? *change_.add_game_event_
      : *reinterpret_cast< ::ssl_protos::gc::AddGameEvent*>(&::ssl_protos::gc::_AddGameEvent_default_instance_);
}
inline ::ssl_protos::gc::AddGameEvent* Change::mutable_add_game_event() {
  if (!has_add_game_event()) {
    clear_change();
    set_has_add_game_event();
    change_.add_game_event_ = CreateMaybeMessage< ::ssl_protos::gc::AddGameEvent >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ssl_protos.gc.Change.add_game_event)
  return change_.add_game_event_;
}

// optional .ssl_protos.gc.AddPassiveGameEvent add_passive_game_event = 19;
inline bool Change::has_add_passive_game_event() const {
  return change_case() == kAddPassiveGameEvent;
}
inline void Change::set_has_add_passive_game_event() {
  _oneof_case_[0] = kAddPassiveGameEvent;
}
inline void Change::clear_add_passive_game_event() {
  if (has_add_passive_game_event()) {
    delete change_.add_passive_game_event_;
    clear_has_change();
  }
}
inline const ::ssl_protos::gc::AddPassiveGameEvent& Change::_internal_add_passive_game_event() const {
  return *change_.add_passive_game_event_;
}
inline ::ssl_protos::gc::AddPassiveGameEvent* Change::release_add_passive_game_event() {
  // @@protoc_insertion_point(field_release:ssl_protos.gc.Change.add_passive_game_event)
  if (has_add_passive_game_event()) {
    clear_has_change();
      ::ssl_protos::gc::AddPassiveGameEvent* temp = change_.add_passive_game_event_;
    change_.add_passive_game_event_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::ssl_protos::gc::AddPassiveGameEvent& Change::add_passive_game_event() const {
  // @@protoc_insertion_point(field_get:ssl_protos.gc.Change.add_passive_game_event)
  return has_add_passive_game_event()
      ? *change_.add_passive_game_event_
      : *reinterpret_cast< ::ssl_protos::gc::AddPassiveGameEvent*>(&::ssl_protos::gc::_AddPassiveGameEvent_default_instance_);
}
inline ::ssl_protos::gc::AddPassiveGameEvent* Change::mutable_add_passive_game_event() {
  if (!has_add_passive_game_event()) {
    clear_change();
    set_has_add_passive_game_event();
    change_.add_passive_game_event_ = CreateMaybeMessage< ::ssl_protos::gc::AddPassiveGameEvent >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ssl_protos.gc.Change.add_passive_game_event)
  return change_.add_passive_game_event_;
}

// optional .ssl_protos.gc.AddProposal add_proposal = 9;
inline bool Change::has_add_proposal() const {
  return change_case() == kAddProposal;
}
inline void Change::set_has_add_proposal() {
  _oneof_case_[0] = kAddProposal;
}
inline void Change::clear_add_proposal() {
  if (has_add_proposal()) {
    delete change_.add_proposal_;
    clear_has_change();
  }
}
inline const ::ssl_protos::gc::AddProposal& Change::_internal_add_proposal() const {
  return *change_.add_proposal_;
}
inline ::ssl_protos::gc::AddProposal* Change::release_add_proposal() {
  // @@protoc_insertion_point(field_release:ssl_protos.gc.Change.add_proposal)
  if (has_add_proposal()) {
    clear_has_change();
      ::ssl_protos::gc::AddProposal* temp = change_.add_proposal_;
    change_.add_proposal_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::ssl_protos::gc::AddProposal& Change::add_proposal() const {
  // @@protoc_insertion_point(field_get:ssl_protos.gc.Change.add_proposal)
  return has_add_proposal()
      ? *change_.add_proposal_
      : *reinterpret_cast< ::ssl_protos::gc::AddProposal*>(&::ssl_protos::gc::_AddProposal_default_instance_);
}
inline ::ssl_protos::gc::AddProposal* Change::mutable_add_proposal() {
  if (!has_add_proposal()) {
    clear_change();
    set_has_add_proposal();
    change_.add_proposal_ = CreateMaybeMessage< ::ssl_protos::gc::AddProposal >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ssl_protos.gc.Change.add_proposal)
  return change_.add_proposal_;
}

// optional .ssl_protos.gc.StartBallPlacement start_ball_placement = 10;
inline bool Change::has_start_ball_placement() const {
  return change_case() == kStartBallPlacement;
}
inline void Change::set_has_start_ball_placement() {
  _oneof_case_[0] = kStartBallPlacement;
}
inline void Change::clear_start_ball_placement() {
  if (has_start_ball_placement()) {
    delete change_.start_ball_placement_;
    clear_has_change();
  }
}
inline const ::ssl_protos::gc::StartBallPlacement& Change::_internal_start_ball_placement() const {
  return *change_.start_ball_placement_;
}
inline ::ssl_protos::gc::StartBallPlacement* Change::release_start_ball_placement() {
  // @@protoc_insertion_point(field_release:ssl_protos.gc.Change.start_ball_placement)
  if (has_start_ball_placement()) {
    clear_has_change();
      ::ssl_protos::gc::StartBallPlacement* temp = change_.start_ball_placement_;
    change_.start_ball_placement_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::ssl_protos::gc::StartBallPlacement& Change::start_ball_placement() const {
  // @@protoc_insertion_point(field_get:ssl_protos.gc.Change.start_ball_placement)
  return has_start_ball_placement()
      ? *change_.start_ball_placement_
      : *reinterpret_cast< ::ssl_protos::gc::StartBallPlacement*>(&::ssl_protos::gc::_StartBallPlacement_default_instance_);
}
inline ::ssl_protos::gc::StartBallPlacement* Change::mutable_start_ball_placement() {
  if (!has_start_ball_placement()) {
    clear_change();
    set_has_start_ball_placement();
    change_.start_ball_placement_ = CreateMaybeMessage< ::ssl_protos::gc::StartBallPlacement >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ssl_protos.gc.Change.start_ball_placement)
  return change_.start_ball_placement_;
}

// optional .ssl_protos.gc.Continue continue = 11;
inline bool Change::has_continue_() const {
  return change_case() == kContinue;
}
inline void Change::set_has_continue_() {
  _oneof_case_[0] = kContinue;
}
inline void Change::clear_continue_() {
  if (has_continue_()) {
    delete change_.continue__;
    clear_has_change();
  }
}
inline const ::ssl_protos::gc::Continue& Change::_internal_continue_() const {
  return *change_.continue__;
}
inline ::ssl_protos::gc::Continue* Change::release_continue_() {
  // @@protoc_insertion_point(field_release:ssl_protos.gc.Change.continue)
  if (has_continue_()) {
    clear_has_change();
      ::ssl_protos::gc::Continue* temp = change_.continue__;
    change_.continue__ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::ssl_protos::gc::Continue& Change::continue_() const {
  // @@protoc_insertion_point(field_get:ssl_protos.gc.Change.continue)
  return has_continue_()
      ? *change_.continue__
      : *reinterpret_cast< ::ssl_protos::gc::Continue*>(&::ssl_protos::gc::_Continue_default_instance_);
}
inline ::ssl_protos::gc::Continue* Change::mutable_continue_() {
  if (!has_continue_()) {
    clear_change();
    set_has_continue_();
    change_.continue__ = CreateMaybeMessage< ::ssl_protos::gc::Continue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ssl_protos.gc.Change.continue)
  return change_.continue__;
}

// optional .ssl_protos.gc.UpdateConfig update_config = 12;
inline bool Change::has_update_config() const {
  return change_case() == kUpdateConfig;
}
inline void Change::set_has_update_config() {
  _oneof_case_[0] = kUpdateConfig;
}
inline void Change::clear_update_config() {
  if (has_update_config()) {
    delete change_.update_config_;
    clear_has_change();
  }
}
inline const ::ssl_protos::gc::UpdateConfig& Change::_internal_update_config() const {
  return *change_.update_config_;
}
inline ::ssl_protos::gc::UpdateConfig* Change::release_update_config() {
  // @@protoc_insertion_point(field_release:ssl_protos.gc.Change.update_config)
  if (has_update_config()) {
    clear_has_change();
      ::ssl_protos::gc::UpdateConfig* temp = change_.update_config_;
    change_.update_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::ssl_protos::gc::UpdateConfig& Change::update_config() const {
  // @@protoc_insertion_point(field_get:ssl_protos.gc.Change.update_config)
  return has_update_config()
      ? *change_.update_config_
      : *reinterpret_cast< ::ssl_protos::gc::UpdateConfig*>(&::ssl_protos::gc::_UpdateConfig_default_instance_);
}
inline ::ssl_protos::gc::UpdateConfig* Change::mutable_update_config() {
  if (!has_update_config()) {
    clear_change();
    set_has_update_config();
    change_.update_config_ = CreateMaybeMessage< ::ssl_protos::gc::UpdateConfig >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ssl_protos.gc.Change.update_config)
  return change_.update_config_;
}

// optional .ssl_protos.gc.UpdateTeamState update_team_state = 13;
inline bool Change::has_update_team_state() const {
  return change_case() == kUpdateTeamState;
}
inline void Change::set_has_update_team_state() {
  _oneof_case_[0] = kUpdateTeamState;
}
inline void Change::clear_update_team_state() {
  if (has_update_team_state()) {
    delete change_.update_team_state_;
    clear_has_change();
  }
}
inline const ::ssl_protos::gc::UpdateTeamState& Change::_internal_update_team_state() const {
  return *change_.update_team_state_;
}
inline ::ssl_protos::gc::UpdateTeamState* Change::release_update_team_state() {
  // @@protoc_insertion_point(field_release:ssl_protos.gc.Change.update_team_state)
  if (has_update_team_state()) {
    clear_has_change();
      ::ssl_protos::gc::UpdateTeamState* temp = change_.update_team_state_;
    change_.update_team_state_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::ssl_protos::gc::UpdateTeamState& Change::update_team_state() const {
  // @@protoc_insertion_point(field_get:ssl_protos.gc.Change.update_team_state)
  return has_update_team_state()
      ? *change_.update_team_state_
      : *reinterpret_cast< ::ssl_protos::gc::UpdateTeamState*>(&::ssl_protos::gc::_UpdateTeamState_default_instance_);
}
inline ::ssl_protos::gc::UpdateTeamState* Change::mutable_update_team_state() {
  if (!has_update_team_state()) {
    clear_change();
    set_has_update_team_state();
    change_.update_team_state_ = CreateMaybeMessage< ::ssl_protos::gc::UpdateTeamState >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ssl_protos.gc.Change.update_team_state)
  return change_.update_team_state_;
}

// optional .ssl_protos.gc.SwitchColors switch_colors = 14;
inline bool Change::has_switch_colors() const {
  return change_case() == kSwitchColors;
}
inline void Change::set_has_switch_colors() {
  _oneof_case_[0] = kSwitchColors;
}
inline void Change::clear_switch_colors() {
  if (has_switch_colors()) {
    delete change_.switch_colors_;
    clear_has_change();
  }
}
inline const ::ssl_protos::gc::SwitchColors& Change::_internal_switch_colors() const {
  return *change_.switch_colors_;
}
inline ::ssl_protos::gc::SwitchColors* Change::release_switch_colors() {
  // @@protoc_insertion_point(field_release:ssl_protos.gc.Change.switch_colors)
  if (has_switch_colors()) {
    clear_has_change();
      ::ssl_protos::gc::SwitchColors* temp = change_.switch_colors_;
    change_.switch_colors_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::ssl_protos::gc::SwitchColors& Change::switch_colors() const {
  // @@protoc_insertion_point(field_get:ssl_protos.gc.Change.switch_colors)
  return has_switch_colors()
      ? *change_.switch_colors_
      : *reinterpret_cast< ::ssl_protos::gc::SwitchColors*>(&::ssl_protos::gc::_SwitchColors_default_instance_);
}
inline ::ssl_protos::gc::SwitchColors* Change::mutable_switch_colors() {
  if (!has_switch_colors()) {
    clear_change();
    set_has_switch_colors();
    change_.switch_colors_ = CreateMaybeMessage< ::ssl_protos::gc::SwitchColors >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ssl_protos.gc.Change.switch_colors)
  return change_.switch_colors_;
}

// optional .ssl_protos.gc.Revert revert = 15;
inline bool Change::has_revert() const {
  return change_case() == kRevert;
}
inline void Change::set_has_revert() {
  _oneof_case_[0] = kRevert;
}
inline void Change::clear_revert() {
  if (has_revert()) {
    delete change_.revert_;
    clear_has_change();
  }
}
inline const ::ssl_protos::gc::Revert& Change::_internal_revert() const {
  return *change_.revert_;
}
inline ::ssl_protos::gc::Revert* Change::release_revert() {
  // @@protoc_insertion_point(field_release:ssl_protos.gc.Change.revert)
  if (has_revert()) {
    clear_has_change();
      ::ssl_protos::gc::Revert* temp = change_.revert_;
    change_.revert_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::ssl_protos::gc::Revert& Change::revert() const {
  // @@protoc_insertion_point(field_get:ssl_protos.gc.Change.revert)
  return has_revert()
      ? *change_.revert_
      : *reinterpret_cast< ::ssl_protos::gc::Revert*>(&::ssl_protos::gc::_Revert_default_instance_);
}
inline ::ssl_protos::gc::Revert* Change::mutable_revert() {
  if (!has_revert()) {
    clear_change();
    set_has_revert();
    change_.revert_ = CreateMaybeMessage< ::ssl_protos::gc::Revert >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ssl_protos.gc.Change.revert)
  return change_.revert_;
}

// optional .ssl_protos.gc.NewGameState new_game_state = 17;
inline bool Change::has_new_game_state() const {
  return change_case() == kNewGameState;
}
inline void Change::set_has_new_game_state() {
  _oneof_case_[0] = kNewGameState;
}
inline void Change::clear_new_game_state() {
  if (has_new_game_state()) {
    delete change_.new_game_state_;
    clear_has_change();
  }
}
inline const ::ssl_protos::gc::NewGameState& Change::_internal_new_game_state() const {
  return *change_.new_game_state_;
}
inline ::ssl_protos::gc::NewGameState* Change::release_new_game_state() {
  // @@protoc_insertion_point(field_release:ssl_protos.gc.Change.new_game_state)
  if (has_new_game_state()) {
    clear_has_change();
      ::ssl_protos::gc::NewGameState* temp = change_.new_game_state_;
    change_.new_game_state_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::ssl_protos::gc::NewGameState& Change::new_game_state() const {
  // @@protoc_insertion_point(field_get:ssl_protos.gc.Change.new_game_state)
  return has_new_game_state()
      ? *change_.new_game_state_
      : *reinterpret_cast< ::ssl_protos::gc::NewGameState*>(&::ssl_protos::gc::_NewGameState_default_instance_);
}
inline ::ssl_protos::gc::NewGameState* Change::mutable_new_game_state() {
  if (!has_new_game_state()) {
    clear_change();
    set_has_new_game_state();
    change_.new_game_state_ = CreateMaybeMessage< ::ssl_protos::gc::NewGameState >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ssl_protos.gc.Change.new_game_state)
  return change_.new_game_state_;
}

// optional .ssl_protos.gc.AcceptProposalGroup accept_proposal_group = 18;
inline bool Change::has_accept_proposal_group() const {
  return change_case() == kAcceptProposalGroup;
}
inline void Change::set_has_accept_proposal_group() {
  _oneof_case_[0] = kAcceptProposalGroup;
}
inline void Change::clear_accept_proposal_group() {
  if (has_accept_proposal_group()) {
    delete change_.accept_proposal_group_;
    clear_has_change();
  }
}
inline const ::ssl_protos::gc::AcceptProposalGroup& Change::_internal_accept_proposal_group() const {
  return *change_.accept_proposal_group_;
}
inline ::ssl_protos::gc::AcceptProposalGroup* Change::release_accept_proposal_group() {
  // @@protoc_insertion_point(field_release:ssl_protos.gc.Change.accept_proposal_group)
  if (has_accept_proposal_group()) {
    clear_has_change();
      ::ssl_protos::gc::AcceptProposalGroup* temp = change_.accept_proposal_group_;
    change_.accept_proposal_group_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::ssl_protos::gc::AcceptProposalGroup& Change::accept_proposal_group() const {
  // @@protoc_insertion_point(field_get:ssl_protos.gc.Change.accept_proposal_group)
  return has_accept_proposal_group()
      ? *change_.accept_proposal_group_
      : *reinterpret_cast< ::ssl_protos::gc::AcceptProposalGroup*>(&::ssl_protos::gc::_AcceptProposalGroup_default_instance_);
}
inline ::ssl_protos::gc::AcceptProposalGroup* Change::mutable_accept_proposal_group() {
  if (!has_accept_proposal_group()) {
    clear_change();
    set_has_accept_proposal_group();
    change_.accept_proposal_group_ = CreateMaybeMessage< ::ssl_protos::gc::AcceptProposalGroup >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ssl_protos.gc.Change.accept_proposal_group)
  return change_.accept_proposal_group_;
}

inline bool Change::has_change() const {
  return change_case() != CHANGE_NOT_SET;
}
inline void Change::clear_has_change() {
  _oneof_case_[0] = CHANGE_NOT_SET;
}
inline Change::ChangeCase Change::change_case() const {
  return Change::ChangeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// NewCommand

// optional .ssl_protos.gc.Command command = 1;
inline bool NewCommand::has_command() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewCommand::set_has_command() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewCommand::clear_has_command() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ssl_protos::gc::Command& NewCommand::_internal_command() const {
  return *command_;
}
inline const ::ssl_protos::gc::Command& NewCommand::command() const {
  const ::ssl_protos::gc::Command* p = command_;
  // @@protoc_insertion_point(field_get:ssl_protos.gc.NewCommand.command)
  return p != NULL ? *p : *reinterpret_cast<const ::ssl_protos::gc::Command*>(
      &::ssl_protos::gc::_Command_default_instance_);
}
inline ::ssl_protos::gc::Command* NewCommand::release_command() {
  // @@protoc_insertion_point(field_release:ssl_protos.gc.NewCommand.command)
  clear_has_command();
  ::ssl_protos::gc::Command* temp = command_;
  command_ = NULL;
  return temp;
}
inline ::ssl_protos::gc::Command* NewCommand::mutable_command() {
  set_has_command();
  if (command_ == NULL) {
    auto* p = CreateMaybeMessage<::ssl_protos::gc::Command>(GetArenaNoVirtual());
    command_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ssl_protos.gc.NewCommand.command)
  return command_;
}
inline void NewCommand::set_allocated_command(::ssl_protos::gc::Command* command) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(command_);
  }
  if (command) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      command = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, command, submessage_arena);
    }
    set_has_command();
  } else {
    clear_has_command();
  }
  command_ = command;
  // @@protoc_insertion_point(field_set_allocated:ssl_protos.gc.NewCommand.command)
}

// -------------------------------------------------------------------

// ChangeStage

// optional .ssl_protos.gc.Referee.Stage new_stage = 1;
inline bool ChangeStage::has_new_stage() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangeStage::set_has_new_stage() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangeStage::clear_has_new_stage() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangeStage::clear_new_stage() {
  new_stage_ = 0;
  clear_has_new_stage();
}
inline ::ssl_protos::gc::Referee_Stage ChangeStage::new_stage() const {
  // @@protoc_insertion_point(field_get:ssl_protos.gc.ChangeStage.new_stage)
  return static_cast< ::ssl_protos::gc::Referee_Stage >(new_stage_);
}
inline void ChangeStage::set_new_stage(::ssl_protos::gc::Referee_Stage value) {
  assert(::ssl_protos::gc::Referee_Stage_IsValid(value));
  set_has_new_stage();
  new_stage_ = value;
  // @@protoc_insertion_point(field_set:ssl_protos.gc.ChangeStage.new_stage)
}

// -------------------------------------------------------------------

// SetBallPlacementPos

// optional .ssl_protos.gc.Vector2 pos = 1;
inline bool SetBallPlacementPos::has_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetBallPlacementPos::set_has_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetBallPlacementPos::clear_has_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ssl_protos::gc::Vector2& SetBallPlacementPos::_internal_pos() const {
  return *pos_;
}
inline const ::ssl_protos::gc::Vector2& SetBallPlacementPos::pos() const {
  const ::ssl_protos::gc::Vector2* p = pos_;
  // @@protoc_insertion_point(field_get:ssl_protos.gc.SetBallPlacementPos.pos)
  return p != NULL ? *p : *reinterpret_cast<const ::ssl_protos::gc::Vector2*>(
      &::ssl_protos::gc::_Vector2_default_instance_);
}
inline ::ssl_protos::gc::Vector2* SetBallPlacementPos::release_pos() {
  // @@protoc_insertion_point(field_release:ssl_protos.gc.SetBallPlacementPos.pos)
  clear_has_pos();
  ::ssl_protos::gc::Vector2* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline ::ssl_protos::gc::Vector2* SetBallPlacementPos::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) {
    auto* p = CreateMaybeMessage<::ssl_protos::gc::Vector2>(GetArenaNoVirtual());
    pos_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ssl_protos.gc.SetBallPlacementPos.pos)
  return pos_;
}
inline void SetBallPlacementPos::set_allocated_pos(::ssl_protos::gc::Vector2* pos) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(pos_);
  }
  if (pos) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pos = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    set_has_pos();
  } else {
    clear_has_pos();
  }
  pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:ssl_protos.gc.SetBallPlacementPos.pos)
}

// -------------------------------------------------------------------

// AddYellowCard

// optional .ssl_protos.gc.Team for_team = 1;
inline bool AddYellowCard::has_for_team() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddYellowCard::set_has_for_team() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddYellowCard::clear_has_for_team() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddYellowCard::clear_for_team() {
  for_team_ = 0;
  clear_has_for_team();
}
inline ::ssl_protos::gc::Team AddYellowCard::for_team() const {
  // @@protoc_insertion_point(field_get:ssl_protos.gc.AddYellowCard.for_team)
  return static_cast< ::ssl_protos::gc::Team >(for_team_);
}
inline void AddYellowCard::set_for_team(::ssl_protos::gc::Team value) {
  assert(::ssl_protos::gc::Team_IsValid(value));
  set_has_for_team();
  for_team_ = value;
  // @@protoc_insertion_point(field_set:ssl_protos.gc.AddYellowCard.for_team)
}

// optional .ssl_protos.gc.GameEvent caused_by_game_event = 2;
inline bool AddYellowCard::has_caused_by_game_event() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddYellowCard::set_has_caused_by_game_event() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddYellowCard::clear_has_caused_by_game_event() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ssl_protos::gc::GameEvent& AddYellowCard::_internal_caused_by_game_event() const {
  return *caused_by_game_event_;
}
inline const ::ssl_protos::gc::GameEvent& AddYellowCard::caused_by_game_event() const {
  const ::ssl_protos::gc::GameEvent* p = caused_by_game_event_;
  // @@protoc_insertion_point(field_get:ssl_protos.gc.AddYellowCard.caused_by_game_event)
  return p != NULL ? *p : *reinterpret_cast<const ::ssl_protos::gc::GameEvent*>(
      &::ssl_protos::gc::_GameEvent_default_instance_);
}
inline ::ssl_protos::gc::GameEvent* AddYellowCard::release_caused_by_game_event() {
  // @@protoc_insertion_point(field_release:ssl_protos.gc.AddYellowCard.caused_by_game_event)
  clear_has_caused_by_game_event();
  ::ssl_protos::gc::GameEvent* temp = caused_by_game_event_;
  caused_by_game_event_ = NULL;
  return temp;
}
inline ::ssl_protos::gc::GameEvent* AddYellowCard::mutable_caused_by_game_event() {
  set_has_caused_by_game_event();
  if (caused_by_game_event_ == NULL) {
    auto* p = CreateMaybeMessage<::ssl_protos::gc::GameEvent>(GetArenaNoVirtual());
    caused_by_game_event_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ssl_protos.gc.AddYellowCard.caused_by_game_event)
  return caused_by_game_event_;
}
inline void AddYellowCard::set_allocated_caused_by_game_event(::ssl_protos::gc::GameEvent* caused_by_game_event) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(caused_by_game_event_);
  }
  if (caused_by_game_event) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      caused_by_game_event = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, caused_by_game_event, submessage_arena);
    }
    set_has_caused_by_game_event();
  } else {
    clear_has_caused_by_game_event();
  }
  caused_by_game_event_ = caused_by_game_event;
  // @@protoc_insertion_point(field_set_allocated:ssl_protos.gc.AddYellowCard.caused_by_game_event)
}

// -------------------------------------------------------------------

// AddRedCard

// optional .ssl_protos.gc.Team for_team = 1;
inline bool AddRedCard::has_for_team() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddRedCard::set_has_for_team() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddRedCard::clear_has_for_team() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddRedCard::clear_for_team() {
  for_team_ = 0;
  clear_has_for_team();
}
inline ::ssl_protos::gc::Team AddRedCard::for_team() const {
  // @@protoc_insertion_point(field_get:ssl_protos.gc.AddRedCard.for_team)
  return static_cast< ::ssl_protos::gc::Team >(for_team_);
}
inline void AddRedCard::set_for_team(::ssl_protos::gc::Team value) {
  assert(::ssl_protos::gc::Team_IsValid(value));
  set_has_for_team();
  for_team_ = value;
  // @@protoc_insertion_point(field_set:ssl_protos.gc.AddRedCard.for_team)
}

// optional .ssl_protos.gc.GameEvent caused_by_game_event = 2;
inline bool AddRedCard::has_caused_by_game_event() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddRedCard::set_has_caused_by_game_event() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddRedCard::clear_has_caused_by_game_event() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ssl_protos::gc::GameEvent& AddRedCard::_internal_caused_by_game_event() const {
  return *caused_by_game_event_;
}
inline const ::ssl_protos::gc::GameEvent& AddRedCard::caused_by_game_event() const {
  const ::ssl_protos::gc::GameEvent* p = caused_by_game_event_;
  // @@protoc_insertion_point(field_get:ssl_protos.gc.AddRedCard.caused_by_game_event)
  return p != NULL ? *p : *reinterpret_cast<const ::ssl_protos::gc::GameEvent*>(
      &::ssl_protos::gc::_GameEvent_default_instance_);
}
inline ::ssl_protos::gc::GameEvent* AddRedCard::release_caused_by_game_event() {
  // @@protoc_insertion_point(field_release:ssl_protos.gc.AddRedCard.caused_by_game_event)
  clear_has_caused_by_game_event();
  ::ssl_protos::gc::GameEvent* temp = caused_by_game_event_;
  caused_by_game_event_ = NULL;
  return temp;
}
inline ::ssl_protos::gc::GameEvent* AddRedCard::mutable_caused_by_game_event() {
  set_has_caused_by_game_event();
  if (caused_by_game_event_ == NULL) {
    auto* p = CreateMaybeMessage<::ssl_protos::gc::GameEvent>(GetArenaNoVirtual());
    caused_by_game_event_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ssl_protos.gc.AddRedCard.caused_by_game_event)
  return caused_by_game_event_;
}
inline void AddRedCard::set_allocated_caused_by_game_event(::ssl_protos::gc::GameEvent* caused_by_game_event) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(caused_by_game_event_);
  }
  if (caused_by_game_event) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      caused_by_game_event = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, caused_by_game_event, submessage_arena);
    }
    set_has_caused_by_game_event();
  } else {
    clear_has_caused_by_game_event();
  }
  caused_by_game_event_ = caused_by_game_event;
  // @@protoc_insertion_point(field_set_allocated:ssl_protos.gc.AddRedCard.caused_by_game_event)
}

// -------------------------------------------------------------------

// YellowCardOver

// optional .ssl_protos.gc.Team for_team = 1;
inline bool YellowCardOver::has_for_team() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void YellowCardOver::set_has_for_team() {
  _has_bits_[0] |= 0x00000001u;
}
inline void YellowCardOver::clear_has_for_team() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void YellowCardOver::clear_for_team() {
  for_team_ = 0;
  clear_has_for_team();
}
inline ::ssl_protos::gc::Team YellowCardOver::for_team() const {
  // @@protoc_insertion_point(field_get:ssl_protos.gc.YellowCardOver.for_team)
  return static_cast< ::ssl_protos::gc::Team >(for_team_);
}
inline void YellowCardOver::set_for_team(::ssl_protos::gc::Team value) {
  assert(::ssl_protos::gc::Team_IsValid(value));
  set_has_for_team();
  for_team_ = value;
  // @@protoc_insertion_point(field_set:ssl_protos.gc.YellowCardOver.for_team)
}

// -------------------------------------------------------------------

// AddGameEvent

// optional .ssl_protos.gc.GameEvent game_event = 1;
inline bool AddGameEvent::has_game_event() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddGameEvent::set_has_game_event() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddGameEvent::clear_has_game_event() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ssl_protos::gc::GameEvent& AddGameEvent::_internal_game_event() const {
  return *game_event_;
}
inline const ::ssl_protos::gc::GameEvent& AddGameEvent::game_event() const {
  const ::ssl_protos::gc::GameEvent* p = game_event_;
  // @@protoc_insertion_point(field_get:ssl_protos.gc.AddGameEvent.game_event)
  return p != NULL ? *p : *reinterpret_cast<const ::ssl_protos::gc::GameEvent*>(
      &::ssl_protos::gc::_GameEvent_default_instance_);
}
inline ::ssl_protos::gc::GameEvent* AddGameEvent::release_game_event() {
  // @@protoc_insertion_point(field_release:ssl_protos.gc.AddGameEvent.game_event)
  clear_has_game_event();
  ::ssl_protos::gc::GameEvent* temp = game_event_;
  game_event_ = NULL;
  return temp;
}
inline ::ssl_protos::gc::GameEvent* AddGameEvent::mutable_game_event() {
  set_has_game_event();
  if (game_event_ == NULL) {
    auto* p = CreateMaybeMessage<::ssl_protos::gc::GameEvent>(GetArenaNoVirtual());
    game_event_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ssl_protos.gc.AddGameEvent.game_event)
  return game_event_;
}
inline void AddGameEvent::set_allocated_game_event(::ssl_protos::gc::GameEvent* game_event) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(game_event_);
  }
  if (game_event) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      game_event = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, game_event, submessage_arena);
    }
    set_has_game_event();
  } else {
    clear_has_game_event();
  }
  game_event_ = game_event;
  // @@protoc_insertion_point(field_set_allocated:ssl_protos.gc.AddGameEvent.game_event)
}

// -------------------------------------------------------------------

// AddPassiveGameEvent

// optional .ssl_protos.gc.GameEvent game_event = 1;
inline bool AddPassiveGameEvent::has_game_event() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddPassiveGameEvent::set_has_game_event() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddPassiveGameEvent::clear_has_game_event() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ssl_protos::gc::GameEvent& AddPassiveGameEvent::_internal_game_event() const {
  return *game_event_;
}
inline const ::ssl_protos::gc::GameEvent& AddPassiveGameEvent::game_event() const {
  const ::ssl_protos::gc::GameEvent* p = game_event_;
  // @@protoc_insertion_point(field_get:ssl_protos.gc.AddPassiveGameEvent.game_event)
  return p != NULL ? *p : *reinterpret_cast<const ::ssl_protos::gc::GameEvent*>(
      &::ssl_protos::gc::_GameEvent_default_instance_);
}
inline ::ssl_protos::gc::GameEvent* AddPassiveGameEvent::release_game_event() {
  // @@protoc_insertion_point(field_release:ssl_protos.gc.AddPassiveGameEvent.game_event)
  clear_has_game_event();
  ::ssl_protos::gc::GameEvent* temp = game_event_;
  game_event_ = NULL;
  return temp;
}
inline ::ssl_protos::gc::GameEvent* AddPassiveGameEvent::mutable_game_event() {
  set_has_game_event();
  if (game_event_ == NULL) {
    auto* p = CreateMaybeMessage<::ssl_protos::gc::GameEvent>(GetArenaNoVirtual());
    game_event_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ssl_protos.gc.AddPassiveGameEvent.game_event)
  return game_event_;
}
inline void AddPassiveGameEvent::set_allocated_game_event(::ssl_protos::gc::GameEvent* game_event) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(game_event_);
  }
  if (game_event) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      game_event = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, game_event, submessage_arena);
    }
    set_has_game_event();
  } else {
    clear_has_game_event();
  }
  game_event_ = game_event;
  // @@protoc_insertion_point(field_set_allocated:ssl_protos.gc.AddPassiveGameEvent.game_event)
}

// -------------------------------------------------------------------

// AddProposal

// optional .ssl_protos.gc.Proposal proposal = 1;
inline bool AddProposal::has_proposal() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddProposal::set_has_proposal() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddProposal::clear_has_proposal() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ssl_protos::gc::Proposal& AddProposal::_internal_proposal() const {
  return *proposal_;
}
inline const ::ssl_protos::gc::Proposal& AddProposal::proposal() const {
  const ::ssl_protos::gc::Proposal* p = proposal_;
  // @@protoc_insertion_point(field_get:ssl_protos.gc.AddProposal.proposal)
  return p != NULL ? *p : *reinterpret_cast<const ::ssl_protos::gc::Proposal*>(
      &::ssl_protos::gc::_Proposal_default_instance_);
}
inline ::ssl_protos::gc::Proposal* AddProposal::release_proposal() {
  // @@protoc_insertion_point(field_release:ssl_protos.gc.AddProposal.proposal)
  clear_has_proposal();
  ::ssl_protos::gc::Proposal* temp = proposal_;
  proposal_ = NULL;
  return temp;
}
inline ::ssl_protos::gc::Proposal* AddProposal::mutable_proposal() {
  set_has_proposal();
  if (proposal_ == NULL) {
    auto* p = CreateMaybeMessage<::ssl_protos::gc::Proposal>(GetArenaNoVirtual());
    proposal_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ssl_protos.gc.AddProposal.proposal)
  return proposal_;
}
inline void AddProposal::set_allocated_proposal(::ssl_protos::gc::Proposal* proposal) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(proposal_);
  }
  if (proposal) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      proposal = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, proposal, submessage_arena);
    }
    set_has_proposal();
  } else {
    clear_has_proposal();
  }
  proposal_ = proposal;
  // @@protoc_insertion_point(field_set_allocated:ssl_protos.gc.AddProposal.proposal)
}

// -------------------------------------------------------------------

// AcceptProposalGroup

// optional uint32 group_id = 1;
inline bool AcceptProposalGroup::has_group_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AcceptProposalGroup::set_has_group_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AcceptProposalGroup::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AcceptProposalGroup::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 AcceptProposalGroup::group_id() const {
  // @@protoc_insertion_point(field_get:ssl_protos.gc.AcceptProposalGroup.group_id)
  return group_id_;
}
inline void AcceptProposalGroup::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
  // @@protoc_insertion_point(field_set:ssl_protos.gc.AcceptProposalGroup.group_id)
}

// optional string accepted_by = 2;
inline bool AcceptProposalGroup::has_accepted_by() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AcceptProposalGroup::set_has_accepted_by() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AcceptProposalGroup::clear_has_accepted_by() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AcceptProposalGroup::clear_accepted_by() {
  accepted_by_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_accepted_by();
}
inline const ::std::string& AcceptProposalGroup::accepted_by() const {
  // @@protoc_insertion_point(field_get:ssl_protos.gc.AcceptProposalGroup.accepted_by)
  return accepted_by_.GetNoArena();
}
inline void AcceptProposalGroup::set_accepted_by(const ::std::string& value) {
  set_has_accepted_by();
  accepted_by_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ssl_protos.gc.AcceptProposalGroup.accepted_by)
}
#if LANG_CXX11
inline void AcceptProposalGroup::set_accepted_by(::std::string&& value) {
  set_has_accepted_by();
  accepted_by_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ssl_protos.gc.AcceptProposalGroup.accepted_by)
}
#endif
inline void AcceptProposalGroup::set_accepted_by(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_accepted_by();
  accepted_by_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ssl_protos.gc.AcceptProposalGroup.accepted_by)
}
inline void AcceptProposalGroup::set_accepted_by(const char* value, size_t size) {
  set_has_accepted_by();
  accepted_by_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ssl_protos.gc.AcceptProposalGroup.accepted_by)
}
inline ::std::string* AcceptProposalGroup::mutable_accepted_by() {
  set_has_accepted_by();
  // @@protoc_insertion_point(field_mutable:ssl_protos.gc.AcceptProposalGroup.accepted_by)
  return accepted_by_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AcceptProposalGroup::release_accepted_by() {
  // @@protoc_insertion_point(field_release:ssl_protos.gc.AcceptProposalGroup.accepted_by)
  if (!has_accepted_by()) {
    return NULL;
  }
  clear_has_accepted_by();
  return accepted_by_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AcceptProposalGroup::set_allocated_accepted_by(::std::string* accepted_by) {
  if (accepted_by != NULL) {
    set_has_accepted_by();
  } else {
    clear_has_accepted_by();
  }
  accepted_by_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), accepted_by);
  // @@protoc_insertion_point(field_set_allocated:ssl_protos.gc.AcceptProposalGroup.accepted_by)
}

// -------------------------------------------------------------------

// StartBallPlacement

// -------------------------------------------------------------------

// Continue

// -------------------------------------------------------------------

// UpdateConfig

// optional .ssl_protos.gc.Division division = 1;
inline bool UpdateConfig::has_division() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateConfig::set_has_division() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateConfig::clear_has_division() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateConfig::clear_division() {
  division_ = 0;
  clear_has_division();
}
inline ::ssl_protos::gc::Division UpdateConfig::division() const {
  // @@protoc_insertion_point(field_get:ssl_protos.gc.UpdateConfig.division)
  return static_cast< ::ssl_protos::gc::Division >(division_);
}
inline void UpdateConfig::set_division(::ssl_protos::gc::Division value) {
  assert(::ssl_protos::gc::Division_IsValid(value));
  set_has_division();
  division_ = value;
  // @@protoc_insertion_point(field_set:ssl_protos.gc.UpdateConfig.division)
}

// optional .ssl_protos.gc.Team first_kickoff_team = 2;
inline bool UpdateConfig::has_first_kickoff_team() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateConfig::set_has_first_kickoff_team() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateConfig::clear_has_first_kickoff_team() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateConfig::clear_first_kickoff_team() {
  first_kickoff_team_ = 0;
  clear_has_first_kickoff_team();
}
inline ::ssl_protos::gc::Team UpdateConfig::first_kickoff_team() const {
  // @@protoc_insertion_point(field_get:ssl_protos.gc.UpdateConfig.first_kickoff_team)
  return static_cast< ::ssl_protos::gc::Team >(first_kickoff_team_);
}
inline void UpdateConfig::set_first_kickoff_team(::ssl_protos::gc::Team value) {
  assert(::ssl_protos::gc::Team_IsValid(value));
  set_has_first_kickoff_team();
  first_kickoff_team_ = value;
  // @@protoc_insertion_point(field_set:ssl_protos.gc.UpdateConfig.first_kickoff_team)
}

// optional bool auto_continue = 3;
inline bool UpdateConfig::has_auto_continue() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpdateConfig::set_has_auto_continue() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpdateConfig::clear_has_auto_continue() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpdateConfig::clear_auto_continue() {
  auto_continue_ = false;
  clear_has_auto_continue();
}
inline bool UpdateConfig::auto_continue() const {
  // @@protoc_insertion_point(field_get:ssl_protos.gc.UpdateConfig.auto_continue)
  return auto_continue_;
}
inline void UpdateConfig::set_auto_continue(bool value) {
  set_has_auto_continue();
  auto_continue_ = value;
  // @@protoc_insertion_point(field_set:ssl_protos.gc.UpdateConfig.auto_continue)
}

// -------------------------------------------------------------------

// UpdateTeamState

// optional .ssl_protos.gc.Team for_team = 1;
inline bool UpdateTeamState::has_for_team() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UpdateTeamState::set_has_for_team() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UpdateTeamState::clear_has_for_team() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UpdateTeamState::clear_for_team() {
  for_team_ = 0;
  clear_has_for_team();
}
inline ::ssl_protos::gc::Team UpdateTeamState::for_team() const {
  // @@protoc_insertion_point(field_get:ssl_protos.gc.UpdateTeamState.for_team)
  return static_cast< ::ssl_protos::gc::Team >(for_team_);
}
inline void UpdateTeamState::set_for_team(::ssl_protos::gc::Team value) {
  assert(::ssl_protos::gc::Team_IsValid(value));
  set_has_for_team();
  for_team_ = value;
  // @@protoc_insertion_point(field_set:ssl_protos.gc.UpdateTeamState.for_team)
}

// optional string team_name = 2;
inline bool UpdateTeamState::has_team_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateTeamState::set_has_team_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateTeamState::clear_has_team_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateTeamState::clear_team_name() {
  team_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_team_name();
}
inline const ::std::string& UpdateTeamState::team_name() const {
  // @@protoc_insertion_point(field_get:ssl_protos.gc.UpdateTeamState.team_name)
  return team_name_.GetNoArena();
}
inline void UpdateTeamState::set_team_name(const ::std::string& value) {
  set_has_team_name();
  team_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ssl_protos.gc.UpdateTeamState.team_name)
}
#if LANG_CXX11
inline void UpdateTeamState::set_team_name(::std::string&& value) {
  set_has_team_name();
  team_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ssl_protos.gc.UpdateTeamState.team_name)
}
#endif
inline void UpdateTeamState::set_team_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_team_name();
  team_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ssl_protos.gc.UpdateTeamState.team_name)
}
inline void UpdateTeamState::set_team_name(const char* value, size_t size) {
  set_has_team_name();
  team_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ssl_protos.gc.UpdateTeamState.team_name)
}
inline ::std::string* UpdateTeamState::mutable_team_name() {
  set_has_team_name();
  // @@protoc_insertion_point(field_mutable:ssl_protos.gc.UpdateTeamState.team_name)
  return team_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UpdateTeamState::release_team_name() {
  // @@protoc_insertion_point(field_release:ssl_protos.gc.UpdateTeamState.team_name)
  if (!has_team_name()) {
    return NULL;
  }
  clear_has_team_name();
  return team_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UpdateTeamState::set_allocated_team_name(::std::string* team_name) {
  if (team_name != NULL) {
    set_has_team_name();
  } else {
    clear_has_team_name();
  }
  team_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), team_name);
  // @@protoc_insertion_point(field_set_allocated:ssl_protos.gc.UpdateTeamState.team_name)
}

// optional int32 goals = 3;
inline bool UpdateTeamState::has_goals() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UpdateTeamState::set_has_goals() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UpdateTeamState::clear_has_goals() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UpdateTeamState::clear_goals() {
  goals_ = 0;
  clear_has_goals();
}
inline ::google::protobuf::int32 UpdateTeamState::goals() const {
  // @@protoc_insertion_point(field_get:ssl_protos.gc.UpdateTeamState.goals)
  return goals_;
}
inline void UpdateTeamState::set_goals(::google::protobuf::int32 value) {
  set_has_goals();
  goals_ = value;
  // @@protoc_insertion_point(field_set:ssl_protos.gc.UpdateTeamState.goals)
}

// optional int32 goalkeeper = 4;
inline bool UpdateTeamState::has_goalkeeper() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UpdateTeamState::set_has_goalkeeper() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UpdateTeamState::clear_has_goalkeeper() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UpdateTeamState::clear_goalkeeper() {
  goalkeeper_ = 0;
  clear_has_goalkeeper();
}
inline ::google::protobuf::int32 UpdateTeamState::goalkeeper() const {
  // @@protoc_insertion_point(field_get:ssl_protos.gc.UpdateTeamState.goalkeeper)
  return goalkeeper_;
}
inline void UpdateTeamState::set_goalkeeper(::google::protobuf::int32 value) {
  set_has_goalkeeper();
  goalkeeper_ = value;
  // @@protoc_insertion_point(field_set:ssl_protos.gc.UpdateTeamState.goalkeeper)
}

// optional int32 timeouts_left = 5;
inline bool UpdateTeamState::has_timeouts_left() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UpdateTeamState::set_has_timeouts_left() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UpdateTeamState::clear_has_timeouts_left() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UpdateTeamState::clear_timeouts_left() {
  timeouts_left_ = 0;
  clear_has_timeouts_left();
}
inline ::google::protobuf::int32 UpdateTeamState::timeouts_left() const {
  // @@protoc_insertion_point(field_get:ssl_protos.gc.UpdateTeamState.timeouts_left)
  return timeouts_left_;
}
inline void UpdateTeamState::set_timeouts_left(::google::protobuf::int32 value) {
  set_has_timeouts_left();
  timeouts_left_ = value;
  // @@protoc_insertion_point(field_set:ssl_protos.gc.UpdateTeamState.timeouts_left)
}

// optional string timeout_time_left = 6;
inline bool UpdateTeamState::has_timeout_time_left() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateTeamState::set_has_timeout_time_left() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateTeamState::clear_has_timeout_time_left() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateTeamState::clear_timeout_time_left() {
  timeout_time_left_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_timeout_time_left();
}
inline const ::std::string& UpdateTeamState::timeout_time_left() const {
  // @@protoc_insertion_point(field_get:ssl_protos.gc.UpdateTeamState.timeout_time_left)
  return timeout_time_left_.GetNoArena();
}
inline void UpdateTeamState::set_timeout_time_left(const ::std::string& value) {
  set_has_timeout_time_left();
  timeout_time_left_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ssl_protos.gc.UpdateTeamState.timeout_time_left)
}
#if LANG_CXX11
inline void UpdateTeamState::set_timeout_time_left(::std::string&& value) {
  set_has_timeout_time_left();
  timeout_time_left_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ssl_protos.gc.UpdateTeamState.timeout_time_left)
}
#endif
inline void UpdateTeamState::set_timeout_time_left(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_timeout_time_left();
  timeout_time_left_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ssl_protos.gc.UpdateTeamState.timeout_time_left)
}
inline void UpdateTeamState::set_timeout_time_left(const char* value, size_t size) {
  set_has_timeout_time_left();
  timeout_time_left_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ssl_protos.gc.UpdateTeamState.timeout_time_left)
}
inline ::std::string* UpdateTeamState::mutable_timeout_time_left() {
  set_has_timeout_time_left();
  // @@protoc_insertion_point(field_mutable:ssl_protos.gc.UpdateTeamState.timeout_time_left)
  return timeout_time_left_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UpdateTeamState::release_timeout_time_left() {
  // @@protoc_insertion_point(field_release:ssl_protos.gc.UpdateTeamState.timeout_time_left)
  if (!has_timeout_time_left()) {
    return NULL;
  }
  clear_has_timeout_time_left();
  return timeout_time_left_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UpdateTeamState::set_allocated_timeout_time_left(::std::string* timeout_time_left) {
  if (timeout_time_left != NULL) {
    set_has_timeout_time_left();
  } else {
    clear_has_timeout_time_left();
  }
  timeout_time_left_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), timeout_time_left);
  // @@protoc_insertion_point(field_set_allocated:ssl_protos.gc.UpdateTeamState.timeout_time_left)
}

// optional bool on_positive_half = 7;
inline bool UpdateTeamState::has_on_positive_half() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void UpdateTeamState::set_has_on_positive_half() {
  _has_bits_[0] |= 0x00000400u;
}
inline void UpdateTeamState::clear_has_on_positive_half() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void UpdateTeamState::clear_on_positive_half() {
  on_positive_half_ = false;
  clear_has_on_positive_half();
}
inline bool UpdateTeamState::on_positive_half() const {
  // @@protoc_insertion_point(field_get:ssl_protos.gc.UpdateTeamState.on_positive_half)
  return on_positive_half_;
}
inline void UpdateTeamState::set_on_positive_half(bool value) {
  set_has_on_positive_half();
  on_positive_half_ = value;
  // @@protoc_insertion_point(field_set:ssl_protos.gc.UpdateTeamState.on_positive_half)
}

// optional int32 ball_placement_failures = 8;
inline bool UpdateTeamState::has_ball_placement_failures() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UpdateTeamState::set_has_ball_placement_failures() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UpdateTeamState::clear_has_ball_placement_failures() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UpdateTeamState::clear_ball_placement_failures() {
  ball_placement_failures_ = 0;
  clear_has_ball_placement_failures();
}
inline ::google::protobuf::int32 UpdateTeamState::ball_placement_failures() const {
  // @@protoc_insertion_point(field_get:ssl_protos.gc.UpdateTeamState.ball_placement_failures)
  return ball_placement_failures_;
}
inline void UpdateTeamState::set_ball_placement_failures(::google::protobuf::int32 value) {
  set_has_ball_placement_failures();
  ball_placement_failures_ = value;
  // @@protoc_insertion_point(field_set:ssl_protos.gc.UpdateTeamState.ball_placement_failures)
}

// optional bool can_place_ball = 9;
inline bool UpdateTeamState::has_can_place_ball() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void UpdateTeamState::set_has_can_place_ball() {
  _has_bits_[0] |= 0x00000800u;
}
inline void UpdateTeamState::clear_has_can_place_ball() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void UpdateTeamState::clear_can_place_ball() {
  can_place_ball_ = false;
  clear_has_can_place_ball();
}
inline bool UpdateTeamState::can_place_ball() const {
  // @@protoc_insertion_point(field_get:ssl_protos.gc.UpdateTeamState.can_place_ball)
  return can_place_ball_;
}
inline void UpdateTeamState::set_can_place_ball(bool value) {
  set_has_can_place_ball();
  can_place_ball_ = value;
  // @@protoc_insertion_point(field_set:ssl_protos.gc.UpdateTeamState.can_place_ball)
}

// optional int32 challenge_flags_left = 21;
inline bool UpdateTeamState::has_challenge_flags_left() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void UpdateTeamState::set_has_challenge_flags_left() {
  _has_bits_[0] |= 0x00080000u;
}
inline void UpdateTeamState::clear_has_challenge_flags_left() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void UpdateTeamState::clear_challenge_flags_left() {
  challenge_flags_left_ = 0;
  clear_has_challenge_flags_left();
}
inline ::google::protobuf::int32 UpdateTeamState::challenge_flags_left() const {
  // @@protoc_insertion_point(field_get:ssl_protos.gc.UpdateTeamState.challenge_flags_left)
  return challenge_flags_left_;
}
inline void UpdateTeamState::set_challenge_flags_left(::google::protobuf::int32 value) {
  set_has_challenge_flags_left();
  challenge_flags_left_ = value;
  // @@protoc_insertion_point(field_set:ssl_protos.gc.UpdateTeamState.challenge_flags_left)
}

// optional bool requests_bot_substitution = 10;
inline bool UpdateTeamState::has_requests_bot_substitution() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void UpdateTeamState::set_has_requests_bot_substitution() {
  _has_bits_[0] |= 0x00001000u;
}
inline void UpdateTeamState::clear_has_requests_bot_substitution() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void UpdateTeamState::clear_requests_bot_substitution() {
  requests_bot_substitution_ = false;
  clear_has_requests_bot_substitution();
}
inline bool UpdateTeamState::requests_bot_substitution() const {
  // @@protoc_insertion_point(field_get:ssl_protos.gc.UpdateTeamState.requests_bot_substitution)
  return requests_bot_substitution_;
}
inline void UpdateTeamState::set_requests_bot_substitution(bool value) {
  set_has_requests_bot_substitution();
  requests_bot_substitution_ = value;
  // @@protoc_insertion_point(field_set:ssl_protos.gc.UpdateTeamState.requests_bot_substitution)
}

// optional bool requests_timeout = 17;
inline bool UpdateTeamState::has_requests_timeout() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void UpdateTeamState::set_has_requests_timeout() {
  _has_bits_[0] |= 0x00002000u;
}
inline void UpdateTeamState::clear_has_requests_timeout() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void UpdateTeamState::clear_requests_timeout() {
  requests_timeout_ = false;
  clear_has_requests_timeout();
}
inline bool UpdateTeamState::requests_timeout() const {
  // @@protoc_insertion_point(field_get:ssl_protos.gc.UpdateTeamState.requests_timeout)
  return requests_timeout_;
}
inline void UpdateTeamState::set_requests_timeout(bool value) {
  set_has_requests_timeout();
  requests_timeout_ = value;
  // @@protoc_insertion_point(field_set:ssl_protos.gc.UpdateTeamState.requests_timeout)
}

// optional bool requests_challenge = 18;
inline bool UpdateTeamState::has_requests_challenge() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void UpdateTeamState::set_has_requests_challenge() {
  _has_bits_[0] |= 0x00020000u;
}
inline void UpdateTeamState::clear_has_requests_challenge() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void UpdateTeamState::clear_requests_challenge() {
  requests_challenge_ = false;
  clear_has_requests_challenge();
}
inline bool UpdateTeamState::requests_challenge() const {
  // @@protoc_insertion_point(field_get:ssl_protos.gc.UpdateTeamState.requests_challenge)
  return requests_challenge_;
}
inline void UpdateTeamState::set_requests_challenge(bool value) {
  set_has_requests_challenge();
  requests_challenge_ = value;
  // @@protoc_insertion_point(field_set:ssl_protos.gc.UpdateTeamState.requests_challenge)
}

// optional bool requests_emergency_stop = 19;
inline bool UpdateTeamState::has_requests_emergency_stop() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void UpdateTeamState::set_has_requests_emergency_stop() {
  _has_bits_[0] |= 0x00040000u;
}
inline void UpdateTeamState::clear_has_requests_emergency_stop() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void UpdateTeamState::clear_requests_emergency_stop() {
  requests_emergency_stop_ = false;
  clear_has_requests_emergency_stop();
}
inline bool UpdateTeamState::requests_emergency_stop() const {
  // @@protoc_insertion_point(field_get:ssl_protos.gc.UpdateTeamState.requests_emergency_stop)
  return requests_emergency_stop_;
}
inline void UpdateTeamState::set_requests_emergency_stop(bool value) {
  set_has_requests_emergency_stop();
  requests_emergency_stop_ = value;
  // @@protoc_insertion_point(field_set:ssl_protos.gc.UpdateTeamState.requests_emergency_stop)
}

// optional .ssl_protos.gc.YellowCard yellow_card = 20;
inline bool UpdateTeamState::has_yellow_card() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UpdateTeamState::set_has_yellow_card() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UpdateTeamState::clear_has_yellow_card() {
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::ssl_protos::gc::YellowCard& UpdateTeamState::_internal_yellow_card() const {
  return *yellow_card_;
}
inline const ::ssl_protos::gc::YellowCard& UpdateTeamState::yellow_card() const {
  const ::ssl_protos::gc::YellowCard* p = yellow_card_;
  // @@protoc_insertion_point(field_get:ssl_protos.gc.UpdateTeamState.yellow_card)
  return p != NULL ? *p : *reinterpret_cast<const ::ssl_protos::gc::YellowCard*>(
      &::ssl_protos::gc::_YellowCard_default_instance_);
}
inline ::ssl_protos::gc::YellowCard* UpdateTeamState::release_yellow_card() {
  // @@protoc_insertion_point(field_release:ssl_protos.gc.UpdateTeamState.yellow_card)
  clear_has_yellow_card();
  ::ssl_protos::gc::YellowCard* temp = yellow_card_;
  yellow_card_ = NULL;
  return temp;
}
inline ::ssl_protos::gc::YellowCard* UpdateTeamState::mutable_yellow_card() {
  set_has_yellow_card();
  if (yellow_card_ == NULL) {
    auto* p = CreateMaybeMessage<::ssl_protos::gc::YellowCard>(GetArenaNoVirtual());
    yellow_card_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ssl_protos.gc.UpdateTeamState.yellow_card)
  return yellow_card_;
}
inline void UpdateTeamState::set_allocated_yellow_card(::ssl_protos::gc::YellowCard* yellow_card) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(yellow_card_);
  }
  if (yellow_card) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      yellow_card = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, yellow_card, submessage_arena);
    }
    set_has_yellow_card();
  } else {
    clear_has_yellow_card();
  }
  yellow_card_ = yellow_card;
  // @@protoc_insertion_point(field_set_allocated:ssl_protos.gc.UpdateTeamState.yellow_card)
}

// optional .ssl_protos.gc.RedCard red_card = 12;
inline bool UpdateTeamState::has_red_card() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpdateTeamState::set_has_red_card() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpdateTeamState::clear_has_red_card() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ssl_protos::gc::RedCard& UpdateTeamState::_internal_red_card() const {
  return *red_card_;
}
inline const ::ssl_protos::gc::RedCard& UpdateTeamState::red_card() const {
  const ::ssl_protos::gc::RedCard* p = red_card_;
  // @@protoc_insertion_point(field_get:ssl_protos.gc.UpdateTeamState.red_card)
  return p != NULL ? *p : *reinterpret_cast<const ::ssl_protos::gc::RedCard*>(
      &::ssl_protos::gc::_RedCard_default_instance_);
}
inline ::ssl_protos::gc::RedCard* UpdateTeamState::release_red_card() {
  // @@protoc_insertion_point(field_release:ssl_protos.gc.UpdateTeamState.red_card)
  clear_has_red_card();
  ::ssl_protos::gc::RedCard* temp = red_card_;
  red_card_ = NULL;
  return temp;
}
inline ::ssl_protos::gc::RedCard* UpdateTeamState::mutable_red_card() {
  set_has_red_card();
  if (red_card_ == NULL) {
    auto* p = CreateMaybeMessage<::ssl_protos::gc::RedCard>(GetArenaNoVirtual());
    red_card_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ssl_protos.gc.UpdateTeamState.red_card)
  return red_card_;
}
inline void UpdateTeamState::set_allocated_red_card(::ssl_protos::gc::RedCard* red_card) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(red_card_);
  }
  if (red_card) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      red_card = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, red_card, submessage_arena);
    }
    set_has_red_card();
  } else {
    clear_has_red_card();
  }
  red_card_ = red_card;
  // @@protoc_insertion_point(field_set_allocated:ssl_protos.gc.UpdateTeamState.red_card)
}

// optional .ssl_protos.gc.Foul foul = 13;
inline bool UpdateTeamState::has_foul() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UpdateTeamState::set_has_foul() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UpdateTeamState::clear_has_foul() {
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::ssl_protos::gc::Foul& UpdateTeamState::_internal_foul() const {
  return *foul_;
}
inline const ::ssl_protos::gc::Foul& UpdateTeamState::foul() const {
  const ::ssl_protos::gc::Foul* p = foul_;
  // @@protoc_insertion_point(field_get:ssl_protos.gc.UpdateTeamState.foul)
  return p != NULL ? *p : *reinterpret_cast<const ::ssl_protos::gc::Foul*>(
      &::ssl_protos::gc::_Foul_default_instance_);
}
inline ::ssl_protos::gc::Foul* UpdateTeamState::release_foul() {
  // @@protoc_insertion_point(field_release:ssl_protos.gc.UpdateTeamState.foul)
  clear_has_foul();
  ::ssl_protos::gc::Foul* temp = foul_;
  foul_ = NULL;
  return temp;
}
inline ::ssl_protos::gc::Foul* UpdateTeamState::mutable_foul() {
  set_has_foul();
  if (foul_ == NULL) {
    auto* p = CreateMaybeMessage<::ssl_protos::gc::Foul>(GetArenaNoVirtual());
    foul_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ssl_protos.gc.UpdateTeamState.foul)
  return foul_;
}
inline void UpdateTeamState::set_allocated_foul(::ssl_protos::gc::Foul* foul) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(foul_);
  }
  if (foul) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      foul = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, foul, submessage_arena);
    }
    set_has_foul();
  } else {
    clear_has_foul();
  }
  foul_ = foul;
  // @@protoc_insertion_point(field_set_allocated:ssl_protos.gc.UpdateTeamState.foul)
}

// optional uint32 remove_yellow_card = 14;
inline bool UpdateTeamState::has_remove_yellow_card() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void UpdateTeamState::set_has_remove_yellow_card() {
  _has_bits_[0] |= 0x00004000u;
}
inline void UpdateTeamState::clear_has_remove_yellow_card() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void UpdateTeamState::clear_remove_yellow_card() {
  remove_yellow_card_ = 0u;
  clear_has_remove_yellow_card();
}
inline ::google::protobuf::uint32 UpdateTeamState::remove_yellow_card() const {
  // @@protoc_insertion_point(field_get:ssl_protos.gc.UpdateTeamState.remove_yellow_card)
  return remove_yellow_card_;
}
inline void UpdateTeamState::set_remove_yellow_card(::google::protobuf::uint32 value) {
  set_has_remove_yellow_card();
  remove_yellow_card_ = value;
  // @@protoc_insertion_point(field_set:ssl_protos.gc.UpdateTeamState.remove_yellow_card)
}

// optional uint32 remove_red_card = 15;
inline bool UpdateTeamState::has_remove_red_card() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void UpdateTeamState::set_has_remove_red_card() {
  _has_bits_[0] |= 0x00008000u;
}
inline void UpdateTeamState::clear_has_remove_red_card() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void UpdateTeamState::clear_remove_red_card() {
  remove_red_card_ = 0u;
  clear_has_remove_red_card();
}
inline ::google::protobuf::uint32 UpdateTeamState::remove_red_card() const {
  // @@protoc_insertion_point(field_get:ssl_protos.gc.UpdateTeamState.remove_red_card)
  return remove_red_card_;
}
inline void UpdateTeamState::set_remove_red_card(::google::protobuf::uint32 value) {
  set_has_remove_red_card();
  remove_red_card_ = value;
  // @@protoc_insertion_point(field_set:ssl_protos.gc.UpdateTeamState.remove_red_card)
}

// optional uint32 remove_foul = 16;
inline bool UpdateTeamState::has_remove_foul() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void UpdateTeamState::set_has_remove_foul() {
  _has_bits_[0] |= 0x00010000u;
}
inline void UpdateTeamState::clear_has_remove_foul() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void UpdateTeamState::clear_remove_foul() {
  remove_foul_ = 0u;
  clear_has_remove_foul();
}
inline ::google::protobuf::uint32 UpdateTeamState::remove_foul() const {
  // @@protoc_insertion_point(field_get:ssl_protos.gc.UpdateTeamState.remove_foul)
  return remove_foul_;
}
inline void UpdateTeamState::set_remove_foul(::google::protobuf::uint32 value) {
  set_has_remove_foul();
  remove_foul_ = value;
  // @@protoc_insertion_point(field_set:ssl_protos.gc.UpdateTeamState.remove_foul)
}

// -------------------------------------------------------------------

// SwitchColors

// -------------------------------------------------------------------

// Revert

// optional int32 change_id = 1;
inline bool Revert::has_change_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Revert::set_has_change_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Revert::clear_has_change_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Revert::clear_change_id() {
  change_id_ = 0;
  clear_has_change_id();
}
inline ::google::protobuf::int32 Revert::change_id() const {
  // @@protoc_insertion_point(field_get:ssl_protos.gc.Revert.change_id)
  return change_id_;
}
inline void Revert::set_change_id(::google::protobuf::int32 value) {
  set_has_change_id();
  change_id_ = value;
  // @@protoc_insertion_point(field_set:ssl_protos.gc.Revert.change_id)
}

// -------------------------------------------------------------------

// NewGameState

// optional .ssl_protos.gc.GameState game_state = 1;
inline bool NewGameState::has_game_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewGameState::set_has_game_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewGameState::clear_has_game_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ssl_protos::gc::GameState& NewGameState::_internal_game_state() const {
  return *game_state_;
}
inline const ::ssl_protos::gc::GameState& NewGameState::game_state() const {
  const ::ssl_protos::gc::GameState* p = game_state_;
  // @@protoc_insertion_point(field_get:ssl_protos.gc.NewGameState.game_state)
  return p != NULL ? *p : *reinterpret_cast<const ::ssl_protos::gc::GameState*>(
      &::ssl_protos::gc::_GameState_default_instance_);
}
inline ::ssl_protos::gc::GameState* NewGameState::release_game_state() {
  // @@protoc_insertion_point(field_release:ssl_protos.gc.NewGameState.game_state)
  clear_has_game_state();
  ::ssl_protos::gc::GameState* temp = game_state_;
  game_state_ = NULL;
  return temp;
}
inline ::ssl_protos::gc::GameState* NewGameState::mutable_game_state() {
  set_has_game_state();
  if (game_state_ == NULL) {
    auto* p = CreateMaybeMessage<::ssl_protos::gc::GameState>(GetArenaNoVirtual());
    game_state_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ssl_protos.gc.NewGameState.game_state)
  return game_state_;
}
inline void NewGameState::set_allocated_game_state(::ssl_protos::gc::GameState* game_state) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(game_state_);
  }
  if (game_state) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      game_state = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, game_state, submessage_arena);
    }
    set_has_game_state();
  } else {
    clear_has_game_state();
  }
  game_state_ = game_state;
  // @@protoc_insertion_point(field_set_allocated:ssl_protos.gc.NewGameState.game_state)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace gc
}  // namespace ssl_protos

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_gc_5fchange_2eproto
